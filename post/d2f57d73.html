<!DOCTYPE html><html lang="zh-Hans" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>【study note】9.python类 | kk</title><meta name="keywords" content="python"><meta name="author" content="wkless"><meta name="copyright" content="wkless"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="本文由 简悦 SimpRead 转码， 原文地址 docs.python.org   类把数据与功能绑定在一起。创建新类就是创建新的对象 类型，从而创建该类型的新 实例 。类实例具有多种保持自身状态的属性。类实例还支持（由类定义的）修改自身状态的方法。  类把数据与功能绑定在一起。创建新类就是创建新的对象 _类型_，从而创建该类型的新 实例 。类实例具有多种保持自身状态的属性。类实例还支持（由类">
<meta property="og:type" content="article">
<meta property="og:title" content="【study note】9.python类">
<meta property="og:url" content="http://example.com/post/d2f57d73.html">
<meta property="og:site_name" content="kk">
<meta property="og:description" content="本文由 简悦 SimpRead 转码， 原文地址 docs.python.org   类把数据与功能绑定在一起。创建新类就是创建新的对象 类型，从而创建该类型的新 实例 。类实例具有多种保持自身状态的属性。类实例还支持（由类定义的）修改自身状态的方法。  类把数据与功能绑定在一起。创建新类就是创建新的对象 _类型_，从而创建该类型的新 实例 。类实例具有多种保持自身状态的属性。类实例还支持（由类">
<meta property="og:locale">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/wklesss/picture@latest/img/photo-1526379095098-d400fd0bf935">
<meta property="article:published_time" content="2021-05-24T11:50:13.000Z">
<meta property="article:modified_time" content="2022-06-09T07:09:39.300Z">
<meta property="article:author" content="wkless">
<meta property="article:tag" content="python">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/wklesss/picture@latest/img/photo-1526379095098-d400fd0bf935"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/post/d2f57d73"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: 'Just',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '【study note】9.python类',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-06-09 15:09:39'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 5.4.2"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://s2.loli.net/2022/06/09/6WAnYe4pymBI5xP.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">21</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">36</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">3</div></a></div><hr/></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://cdn.jsdelivr.net/gh/wklesss/picture@latest/img/photo-1526379095098-d400fd0bf935')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">kk</a></span><div id="menus"><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">【study note】9.python类</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2021-05-24T11:50:13.000Z" title="Created 2021-05-24 19:50:13">2021-05-24</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2022-06-09T07:09:39.300Z" title="Updated 2022-06-09 15:09:39">2022-06-09</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">学习笔记</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="【study note】9.python类"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post View:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><blockquote>
<p>本文由 <a target="_blank" rel="noopener" href="http://ksria.com/simpread/">简悦 SimpRead</a> 转码， 原文地址 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/tutorial/classes.html">docs.python.org</a></p>
</blockquote>
<blockquote>
<p>类把数据与功能绑定在一起。创建新类就是创建新的对象 类型，从而创建该类型的新 实例 。类实例具有多种保持自身状态的属性。类实例还支持（由类定义的）修改自身状态的方法。</p>
</blockquote>
<p>类把数据与功能绑定在一起。创建新类就是创建新的对象 _类型_，从而创建该类型的新 <em>实例</em> 。类实例具有多种保持自身状态的属性。类实例还支持（由类定义的）修改自身状态的方法。</p>
<p>和其他编程语言相比，Python 用非常少的新语法和语义将类加入到语言中。它是 C++ 和 Modula-3 中类机制的结合体。Python 的类提供了面向对象编程（OOP）的所有标准特性：类继承机制允许多个基类，派生类可以覆盖它基类的任何方法，一个方法可以调用基类中相同名称的的方法。对象可以包含任意数量和类型的数据。和模块一样，类也拥有 Python 天然的动态特性：在运行时创建，创建后可以修改。</p>
<p>在 C++ 术语中，通常类成员（包括数据成员）是 <em>public</em> (例外见下文 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/tutorial/classes.html#tut-private">私有变量</a>)，所有成员函数都是 _virtual_。 与在 Modula-3 中一样，没有用于从对象的方法中引用对象成员的简写：方法函数在声明时，有一个显示的参数代表本对象，该参数由调用隐式提供。 与 Smalltalk 一样，类本身也是对象。 这为导入和重命名提供了语义。 与 C++ 和 Modula-3 不同，内置类型可以用作基类，供用户扩展。 此外，与 C++ 一样，大多数具有特殊语法（算术运算符，下标等）的内置运算符都可以为类实例而重新定义。</p>
<p>（由于缺乏关于类的公认术语，我会偶尔使用 Smalltalk、C++ 的术语，我还会使用 Modula-3 的术语，因为它的面向对象语义比 C++ 更接近 Python，但估计没几个读者听说过这门语言。）</p>
<h2 id="9-1-名称和对象-¶"><a href="#9-1-名称和对象-¶" class="headerlink" title="9.1. 名称和对象 ¶"></a>9.1. 名称和对象 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/tutorial/classes.html#a-word-about-names-and-objects" title="永久链接至标题">¶</a></h2><p>对象之间相互独立，多个名称（在多个作用域内）可以绑定到同一个对象。 其他语言称之为别名。Python 初学者通常不容易理解这个概念，处理数字、字符串、元组等不可变基本类型时，可以不必理会。 但是，对涉及可变对象，如列表、字典等大多数其他类型的 Python 代码的语义，别名可能会产生意料之外的效果。这样做，通常是为了让程序受益，因为别名在某些方面就像指针。例如，传递对象的代价很小，因为实现只传递一个指针；如果函数修改了作为参数传递的对象，调用者就可以看到更改 — 无需 Pascal 用两个不同参数的传递机制。</p>
<h2 id="9-2-Python-作用域和命名空间-¶"><a href="#9-2-Python-作用域和命名空间-¶" class="headerlink" title="9.2. Python 作用域和命名空间 ¶"></a>9.2. Python 作用域和命名空间 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/tutorial/classes.html#python-scopes-and-namespaces" title="永久链接至标题">¶</a></h2><p>在介绍类之前，我首先要告诉你一些 Python 的作用域规则。类定义对命名空间有一些巧妙的技巧，你需要知道作用域和命名空间如何工作才能完全理解正在发生的事情。顺便说一下，关于这个主题的知识对任何高级 Python 程序员都很有用。</p>
<p>让我们从一些定义开始。</p>
<p><em>namespace</em> （命名空间）是一个从名字到对象的映射。 当前大部分命名空间都由 Python 字典实现，但一般情况下基本不会去关注它们（除了要面对性能问题时），而且也有可能在将来更改。 下面是几个命名空间的例子：存放内置函数的集合（包含 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/library/functions.html#abs" title="abs"><code>abs()</code></a> 这样的函数，和内建的异常等）；模块中的全局名称；函数调用中的局部名称。 从某种意义上说，对象的属性集合也是一种命名空间的形式。 关于命名空间的重要一点是，不同命名空间中的名称之间绝对没有关系；例如，两个不同的模块都可以定义一个 <code>maximize</code> 函数而不会产生混淆 — 模块的用户必须在其前面加上模块名称。</p>
<p>顺便说明一下，我把任何跟在一个点号之后的名称都称为 <em>属性</em> — 例如，在表达式 <code>z.real</code> 中，<code>real</code> 是对象 <code>z</code> 的一个属性。按严格的说法，对模块中名称的引用属于属性引用：在表达式 <code>modname.funcname</code> 中，<code>modname</code> 是一个模块对象而 <code>funcname</code> 是它的一个属性。在此情况下在模块的属性和模块中定义的全局名称之间正好存在一个直观的映射：它们共享相同的命名空间！ <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/tutorial/classes.html#id2">1</a></p>
<p>属性可以是只读或者可写的。如果为后者，那么对属性的赋值是可行的。模块属性是可写的，你可以写 <code>modname.the_answer = 42</code> 。可写的属性同样可以用 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/reference/simple_stmts.html#del"><code>del</code></a> 语句删除。例如， <code>del modname.the_answer</code> 将会从名为 <code>modname</code> 的对象中移除 <code>the_answer</code> 属性。</p>
<p>命名空间在不同时刻被创建，拥有不同的生存期。包含内置名称的命名空间是在 Python 解释器启动时创建的，永远不会被删除。模块的全局命名空间在模块定义被读入时创建；通常，模块命名空间也会持续到解释器退出。被解释器的顶层调用执行的语句，从一个脚本文件读取或交互式地读取，被认为是 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/library/__main__.html#module-__main__" title="__main__: The environment where the top-level script is run."><code>__main__</code></a> 模块调用的一部分，因此它们拥有自己的全局命名空间。（内置名称实际上也存在于一个模块中；这个模块被称作 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/library/builtins.html#module-builtins" title="builtins: The module that provides the built-in namespace."><code>builtins</code></a> 。）</p>
<p>一个函数的本地命名空间在这个函数被调用时创建，并在函数返回或抛出一个不在函数内部处理的错误时被删除。（事实上，比起描述到底发生了什么，忘掉它更好。）当然，每次递归调用都会有它自己的本地命名空间。</p>
<p>一个 <em>作用域</em> 是一个命名空间可直接访问的 Python 程序的文本区域。 这里的 “可直接访问” 意味着对名称的非限定引用会尝试在命名空间中查找名称。</p>
<p>虽然作用域是静态地确定的，但它们会被动态地使用。 在执行期间的任何时刻，会有 3 或 4 个命名空间可被直接访问的嵌套作用域:</p>
<ul>
<li><p>  最先搜索的最内部作用域包含局部名称</p>
</li>
<li><p>  从最近的封闭作用域开始搜索的任何封闭函数的作用域包含非局部名称，也包括非全局名称</p>
</li>
<li><p>  倒数第二个作用域包含当前模块的全局名称</p>
</li>
<li><p>  最外面的作用域（最后搜索）是包含内置名称的命名空间</p>
</li>
</ul>
<p>如果一个名称被声明为全局变量，则所有引用和赋值将直接指向包含该模块的全局名称的中间作用域。 要重新绑定在最内层作用域以外找到的变量，可以使用 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/reference/simple_stmts.html#nonlocal"><code>nonlocal</code></a> 语句声明为非本地变量。 如果没有被声明为非本地变量，这些变量将是只读的（尝试写入这样的变量只会在最内层作用域中创建一个 <em>新的</em> 局部变量，而同名的外部变量保持不变）。</p>
<p>通常，当前局部作用域将（按字面文本）引用当前函数的局部名称。 在函数以外，局部作用域将引用与全局作用域相一致的命名空间：模块的命名空间。 类定义将在局部命名空间内再放置另一个命名空间。</p>
<p>重要的是应该意识到作用域是按字面文本来确定的：在一个模块内定义的函数的全局作用域就是该模块的命名空间，无论该函数从什么地方或以什么别名被调用。 另一方面，实际的名称搜索是在运行时动态完成的 — 但是，Python 正在朝着 “编译时静态名称解析” 的方向发展，因此不要过于依赖动态名称解析！ （事实上，局部变量已经是被静态确定了。）</p>
<p>Python 的一个特殊规定是这样的 – 如果不存在生效的 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/reference/simple_stmts.html#global"><code>global</code></a> 或 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/reference/simple_stmts.html#nonlocal"><code>nonlocal</code></a> 语句 – 则对名称的赋值总是会进入最内层作用域。 赋值不会复制数据 — 它们只是将名称绑定到对象。 删除也是如此：语句 <code>del x</code> 会从局部作用域所引用的命名空间中移除对 <code>x</code> 的绑定。 事实上，所有引入新名称的操作都是使用局部作用域：特别地，<a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/reference/simple_stmts.html#import"><code>import</code></a> 语句和函数定义会在局部作用域中绑定模块或函数名称。</p>
<p><a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/reference/simple_stmts.html#global"><code>global</code></a> 语句可被用来表明特定变量生存于全局作用域并且应当在其中被重新绑定；<a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/reference/simple_stmts.html#nonlocal"><code>nonlocal</code></a> 语句表明特定变量生存于外层作用域中并且应当在其中被重新绑定。</p>
<h3 id="9-2-1-作用域和命名空间示例-¶"><a href="#9-2-1-作用域和命名空间示例-¶" class="headerlink" title="9.2.1. 作用域和命名空间示例 ¶"></a>9.2.1. 作用域和命名空间示例 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/tutorial/classes.html#scopes-and-namespaces-example" title="永久链接至标题">¶</a></h3><p>这个例子演示了如何引用不同作用域和名称空间，以及 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/reference/simple_stmts.html#global"><code>global</code></a> 和 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/reference/simple_stmts.html#nonlocal"><code>nonlocal</code></a> 会如何影响变量绑定:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">scope_test</span>():</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">do_local</span>():</span><br>        spam = <span class="hljs-string">&quot;local spam&quot;</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">do_nonlocal</span>():</span><br>        <span class="hljs-keyword">nonlocal</span> spam<br>        spam = <span class="hljs-string">&quot;nonlocal spam&quot;</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">do_global</span>():</span><br>        <span class="hljs-keyword">global</span> spam<br>        spam = <span class="hljs-string">&quot;global spam&quot;</span><br><br>    spam = <span class="hljs-string">&quot;test spam&quot;</span><br>    do_local()<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;After local assignment:&quot;</span>, spam)<br>    do_nonlocal()<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;After nonlocal assignment:&quot;</span>, spam)<br>    do_global()<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;After global assignment:&quot;</span>, spam)<br><br>scope_test()<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;In global scope:&quot;</span>, spam)<br></code></pre></td></tr></table></figure>

<p>示例代码的输出是：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">After local assignment: test spam<br>After <span class="hljs-keyword">nonlocal</span> assignment: <span class="hljs-keyword">nonlocal</span> spam<br>After <span class="hljs-keyword">global</span> assignment: <span class="hljs-keyword">nonlocal</span> spam<br>In <span class="hljs-keyword">global</span> scope: <span class="hljs-keyword">global</span> spam<br></code></pre></td></tr></table></figure>

<p>请注意 <em>局部</em> 赋值（这是默认状态）不会改变 <em>scope_test</em> 对 <em>spam</em> 的绑定。 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/reference/simple_stmts.html#nonlocal"><code>nonlocal</code></a> 赋值会改变 <em>scope_test</em> 对 <em>spam</em> 的绑定，而 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/reference/simple_stmts.html#global"><code>global</code></a> 赋值会改变模块层级的绑定。</p>
<p>您还可以发现在 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/reference/simple_stmts.html#global"><code>global</code></a> 赋值之前没有 <em>spam</em> 的绑定。</p>
<h2 id="9-3-初探类-¶"><a href="#9-3-初探类-¶" class="headerlink" title="9.3. 初探类 ¶"></a>9.3. 初探类 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/tutorial/classes.html#a-first-look-at-classes" title="永久链接至标题">¶</a></h2><p>类引入了一些新语法，三种新对象类型和一些新语义。</p>
<h3 id="9-3-1-类定义语法-¶"><a href="#9-3-1-类定义语法-¶" class="headerlink" title="9.3.1. 类定义语法 ¶"></a>9.3.1. 类定义语法 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/tutorial/classes.html#class-definition-syntax" title="永久链接至标题">¶</a></h3><p>最简单的类定义看起来像这样:</p>
<figure class="highlight erlang"><table><tr><td class="code"><pre><code class="hljs erlang">class ClassName:<br>    &lt;statement-<span class="hljs-number">1</span>&gt;<br>    .<br>    .<br>    .<br>    &lt;statement-N&gt;<br></code></pre></td></tr></table></figure>

<p>类定义与函数定义 (<a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/reference/compound_stmts.html#def"><code>def</code></a> 语句) 一样必须被执行才会起作用。 （你可以尝试将类定义放在 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/reference/compound_stmts.html#if"><code>if</code></a> 语句的一个分支或是函数的内部。）</p>
<p>在实践中，类定义内的语句通常都是函数定义，但也允许有其他语句，有时还很有用 — 我们会稍后再回来说明这个问题。 在类内部的函数定义通常具有一种特别形式的参数列表，这是方法调用的约定规范所指明的 — 这个问题也将在稍后再说明。</p>
<p>当进入类定义时，将创建一个新的命名空间，并将其用作局部作用域 — 因此，所有对局部变量的赋值都是在这个新命名空间之内。 特别的，函数定义会绑定到这里的新函数名称。</p>
<p>当（从结尾处）正常离开类定义时，将创建一个 _类对象_。 这基本上是一个包围在类定义所创建命名空间内容周围的包装器；我们将在下一节了解有关类对象的更多信息。 原始的（在进入类定义之前起作用的）局部作用域将重新生效，类对象将在这里被绑定到类定义头所给出的类名称 (在这个示例中为 <code>ClassName</code>)。</p>
<h3 id="9-3-2-类对象-¶"><a href="#9-3-2-类对象-¶" class="headerlink" title="9.3.2. 类对象 ¶"></a>9.3.2. 类对象 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/tutorial/classes.html#class-objects" title="永久链接至标题">¶</a></h3><p>类对象支持两种操作：属性引用和实例化。</p>
<p><em>属性引用</em> 使用 Python 中所有属性引用所使用的标准语法: <code>obj.name</code>。 有效的属性名称是类对象被创建时存在于类命名空间中的所有名称。 因此，如果类定义是这样的:</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">class</span> <span class="hljs-symbol">MyClass:</span><br><span class="hljs-symbol">    </span>&quot;&quot;&quot;<span class="hljs-symbol">A</span> <span class="hljs-symbol">simple</span> <span class="hljs-symbol">example</span> <span class="hljs-symbol">class</span>&quot;&quot;&quot;<br>    <span class="hljs-symbol">i</span> = <span class="hljs-symbol">12345</span><br><br>    <span class="hljs-symbol">def</span> <span class="hljs-symbol">f</span>(<span class="hljs-symbol">self</span>):<br>        <span class="hljs-symbol">return</span> &#x27;<span class="hljs-symbol">hello</span> <span class="hljs-symbol">world</span>&#x27;<br></code></pre></td></tr></table></figure>

<p>那么 <code>MyClass.i</code> 和 <code>MyClass.f</code> 就是有效的属性引用，将分别返回一个整数和一个函数对象。 类属性也可以被赋值，因此可以通过赋值来更改 <code>MyClass.i</code> 的值。 <code>__doc__</code> 也是一个有效的属性，将返回所属类的文档字符串: <code>&quot;A simple example class&quot;</code>。</p>
<p>类的 <em>实例化</em> 使用函数表示法。 可以把类对象视为是返回该类的一个新实例的不带参数的函数。 举例来说（假设使用上述的类）:</p>
<p>创建类的新 <em>实例</em> 并将此对象分配给局部变量 <code>x</code>。</p>
<p>实例化操作（“调用” 类对象）会创建一个空对象。 许多类喜欢创建带有特定初始状态的自定义实例。 为此类定义可能包含一个名为 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/reference/datamodel.html#object.__init__" title="object.__init__"><code>__init__()</code></a> 的特殊方法，就像这样:</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><code class="hljs ruby"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(<span class="hljs-keyword">self</span>)</span></span>:<br>    <span class="hljs-keyword">self</span>.data = []<br></code></pre></td></tr></table></figure>

<p>当一个类定义了 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/reference/datamodel.html#object.__init__" title="object.__init__"><code>__init__()</code></a> 方法时，类的实例化操作会自动为新创建的类实例发起调用 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/reference/datamodel.html#object.__init__" title="object.__init__"><code>__init__()</code></a>。 因此在这个示例中，可以通过以下语句获得一个经初始化的新实例:</p>
<p>当然，<a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/reference/datamodel.html#object.__init__" title="object.__init__"><code>__init__()</code></a> 方法还可以有额外参数以实现更高灵活性。 在这种情况下，提供给类实例化运算符的参数将被传递给 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/reference/datamodel.html#object.__init__" title="object.__init__"><code>__init__()</code></a>。 例如，:</p>
<blockquote>
</blockquote>
<figure class="highlight python-repl"><table><tr><td class="code"><pre><code class="hljs python-repl"><span class="hljs-meta">&gt;&gt;&gt;</span> <span class="python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Complex</span>:</span></span><br><span class="hljs-meta">...</span> <span class="python">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, realpart, imagpart</span>):</span></span><br><span class="hljs-meta">...</span> <span class="python">        self.r = realpart</span><br><span class="hljs-meta">...</span> <span class="python">        self.i = imagpart</span><br><span class="hljs-meta">...</span><br><span class="hljs-meta">&gt;&gt;&gt;</span> <span class="python">x = Complex(<span class="hljs-number">3.0</span>, -<span class="hljs-number">4.5</span>)</span><br><span class="hljs-meta">&gt;&gt;&gt;</span> <span class="python">x.r, x.i</span><br>(3.0, -4.5)<br></code></pre></td></tr></table></figure>

<h3 id="9-3-3-实例对象-¶"><a href="#9-3-3-实例对象-¶" class="headerlink" title="9.3.3. 实例对象 ¶"></a>9.3.3. 实例对象 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/tutorial/classes.html#instance-objects" title="永久链接至标题">¶</a></h3><p>现在我们能用实例对象做什么？ 实例对象所能理解的唯一操作是属性引用。 有两种有效的属性名称：数据属性和方法。</p>
<p><em>数据属性</em> 对应于 Smalltalk 中的 “实例变量”，以及 C++ 中的 “数据成员”。 数据属性不需要声明；像局部变量一样，它们将在第一次被赋值时产生。 例如，如果 <code>x</code> 是上面创建的 <code>MyClass</code> 的实例，则以下代码段将打印数值 <code>16</code>，且不保留任何追踪信息:</p>
<figure class="highlight llvm"><table><tr><td class="code"><pre><code class="hljs llvm"><span class="hljs-keyword">x</span>.counter <span class="hljs-operator">=</span> <span class="hljs-number">1</span><br>while <span class="hljs-keyword">x</span>.counter &lt; <span class="hljs-number">10</span>:<br>    <span class="hljs-keyword">x</span>.counter <span class="hljs-operator">=</span> <span class="hljs-keyword">x</span>.counter * <span class="hljs-number">2</span><br>print(<span class="hljs-keyword">x</span>.counter)<br>del <span class="hljs-keyword">x</span>.counter<br></code></pre></td></tr></table></figure>

<p>另一类实例属性引用称为 _方法_。 方法是 “从属于” 对象的函数。 （在 Python 中，方法这个术语并不是类实例所特有的：其他对象也可以有方法。 例如，列表对象具有 append, insert, remove, sort 等方法。 然而，在以下讨论中，我们使用方法一词将专指类实例对象的方法，除非另外显式地说明。）</p>
<p>实例对象的有效方法名称依赖于其所属的类。 根据定义，一个类中所有是函数对象的属性都是定义了其实例的相应方法。 因此在我们的示例中，<code>x.f</code> 是有效的方法引用，因为 <code>MyClass.f</code> 是一个函数，而 <code>x.i</code> 不是方法，因为 <code>MyClass.i</code> 不是函数。 但是 <code>x.f</code> 与 <code>MyClass.f</code> 并不是一回事 — 它是一个 _方法对象_，不是函数对象。</p>
<h3 id="9-3-4-方法对象-¶"><a href="#9-3-4-方法对象-¶" class="headerlink" title="9.3.4. 方法对象 ¶"></a>9.3.4. 方法对象 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/tutorial/classes.html#method-objects" title="永久链接至标题">¶</a></h3><p>通常，方法在绑定后立即被调用:</p>
<p>在 <code>MyClass</code> 示例中，这将返回字符串 <code>&#39;hello world&#39;</code>。 但是，立即调用一个方法并不是必须的: <code>x.f</code> 是一个方法对象，它可以被保存起来以后再调用。 例如:</p>
<figure class="highlight isbl"><table><tr><td class="code"><pre><code class="hljs isbl"><span class="hljs-variable">xf</span> = <span class="hljs-variable">x.f</span><br><span class="hljs-variable"><span class="hljs-keyword">while</span></span> <span class="hljs-variable"><span class="hljs-literal">True</span></span>:<br>    <span class="hljs-function"><span class="hljs-title">print</span>(<span class="hljs-title">xf</span>())</span><br></code></pre></td></tr></table></figure>

<p>将持续打印 <code>hello world</code>，直到结束。</p>
<p>当一个方法被调用时到底发生了什么？ 你可能已经注意到上面调用 <code>x.f()</code> 时并没有带参数，虽然 <code>f()</code> 的函数定义指定了一个参数。 这个参数发生了什么事？ 当不带参数地调用一个需要参数的函数时 Python 肯定会引发异常 — 即使参数实际未被使用…</p>
<p>实际上，你可能已经猜到了答案：方法的特殊之处就在于实例对象会作为函数的第一个参数被传入。 在我们的示例中，调用 <code>x.f()</code> 其实就相当于 <code>MyClass.f(x)</code>。 总之，调用一个具有 <em>n</em> 个参数的方法就相当于调用再多一个参数的对应函数，这个参数值为方法所属实例对象，位置在其他参数之前。</p>
<p>如果你仍然无法理解方法的运作原理，那么查看实现细节可能会弄清楚问题。 当一个实例的非数据属性被引用时，将搜索实例所属的类。 如果被引用的属性名称表示一个有效的类属性中的函数对象，会通过打包（指向）查找到的实例对象和函数对象到一个抽象对象的方式来创建方法对象：这个抽象对象就是方法对象。 当附带参数列表调用方法对象时，将基于实例对象和参数列表构建一个新的参数列表，并使用这个新参数列表调用相应的函数对象。</p>
<h3 id="9-3-5-类和实例变量-¶"><a href="#9-3-5-类和实例变量-¶" class="headerlink" title="9.3.5. 类和实例变量 ¶"></a>9.3.5. 类和实例变量 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/tutorial/classes.html#class-and-instance-variables" title="永久链接至标题">¶</a></h3><p>一般来说，实例变量用于每个实例的唯一数据，而类变量用于类的所有实例共享的属性和方法:</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">class</span> Dog:    kind = <span class="hljs-string">&#x27;canine&#x27;</span>         # <span class="hljs-keyword">class</span> variable shared <span class="hljs-keyword">by</span> <span class="hljs-keyword">all</span> instances    def __init__(self, <span class="hljs-type">name</span>):        self.name = <span class="hljs-type">name</span>    # instance variable <span class="hljs-keyword">unique</span> <span class="hljs-keyword">to</span> <span class="hljs-keyword">each</span> instance&gt;&gt;&gt; d = Dog(<span class="hljs-string">&#x27;Fido&#x27;</span>)&gt;&gt;&gt; e = Dog(<span class="hljs-string">&#x27;Buddy&#x27;</span>)&gt;&gt;&gt; d.kind                  # shared <span class="hljs-keyword">by</span> <span class="hljs-keyword">all</span> dogs<span class="hljs-string">&#x27;canine&#x27;</span>&gt;&gt;&gt; e.kind                  # shared <span class="hljs-keyword">by</span> <span class="hljs-keyword">all</span> dogs<span class="hljs-string">&#x27;canine&#x27;</span>&gt;&gt;&gt; d.name                  # <span class="hljs-keyword">unique</span> <span class="hljs-keyword">to</span> d<span class="hljs-string">&#x27;Fido&#x27;</span>&gt;&gt;&gt; e.name                  # <span class="hljs-keyword">unique</span> <span class="hljs-keyword">to</span> <span class="hljs-string">e&#x27;Buddy&#x27;</span><br></code></pre></td></tr></table></figure>

<p>正如 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/tutorial/classes.html#tut-object">名称和对象</a> 中已讨论过的，共享数据可能在涉及 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/glossary.html#term-mutable">mutable</a> 对象例如列表和字典的时候导致令人惊讶的结果。 例如以下代码中的 <em>tricks</em> 列表不应该被用作类变量，因为所有的 <em>Dog</em> 实例将只共享一个单独的列表:</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">class</span> Dog:    tricks = <span class="hljs-literal">[]</span>             # mistaken use <span class="hljs-keyword">of</span> a <span class="hljs-keyword">class</span> variable    def <span class="hljs-constructor">__init__(<span class="hljs-params">self</span>, <span class="hljs-params">name</span>)</span>:        self.name = name    def add<span class="hljs-constructor">_trick(<span class="hljs-params">self</span>, <span class="hljs-params">trick</span>)</span>:        self.tricks.append(trick)&gt;&gt;&gt; d = <span class="hljs-constructor">Dog(&#x27;Fido&#x27;)</span>&gt;&gt;&gt; e = <span class="hljs-constructor">Dog(&#x27;Buddy&#x27;)</span>&gt;&gt;&gt; d.add<span class="hljs-constructor">_trick(&#x27;<span class="hljs-params">roll</span> <span class="hljs-params">over</span>&#x27;)</span>&gt;&gt;&gt; e.add<span class="hljs-constructor">_trick(&#x27;<span class="hljs-params">play</span> <span class="hljs-params">dead</span>&#x27;)</span>&gt;&gt;&gt; d.tricks                # unexpectedly shared by all dogs<span class="hljs-literal">[&#x27;<span class="hljs-identifier">roll</span> <span class="hljs-identifier">over</span>&#x27;, &#x27;<span class="hljs-identifier">play</span> <span class="hljs-identifier">dead</span>&#x27;]</span><br></code></pre></td></tr></table></figure>

<p>正确的类设计应该使用实例变量:</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">class</span> Dog:    def <span class="hljs-constructor">__init__(<span class="hljs-params">self</span>, <span class="hljs-params">name</span>)</span>:        self.name = name        self.tricks = <span class="hljs-literal">[]</span>    # creates a <span class="hljs-keyword">new</span> empty <span class="hljs-built_in">list</span> <span class="hljs-keyword">for</span> each dog    def add<span class="hljs-constructor">_trick(<span class="hljs-params">self</span>, <span class="hljs-params">trick</span>)</span>:        self.tricks.append(trick)&gt;&gt;&gt; d = <span class="hljs-constructor">Dog(&#x27;Fido&#x27;)</span>&gt;&gt;&gt; e = <span class="hljs-constructor">Dog(&#x27;Buddy&#x27;)</span>&gt;&gt;&gt; d.add<span class="hljs-constructor">_trick(&#x27;<span class="hljs-params">roll</span> <span class="hljs-params">over</span>&#x27;)</span>&gt;&gt;&gt; e.add<span class="hljs-constructor">_trick(&#x27;<span class="hljs-params">play</span> <span class="hljs-params">dead</span>&#x27;)</span>&gt;&gt;&gt; d.tricks<span class="hljs-literal">[&#x27;<span class="hljs-identifier">roll</span> <span class="hljs-identifier">over</span>&#x27;]</span>&gt;&gt;&gt; e.tricks<span class="hljs-literal">[&#x27;<span class="hljs-identifier">play</span> <span class="hljs-identifier">dead</span>&#x27;]</span><br></code></pre></td></tr></table></figure>

<h2 id="9-4-补充说明-¶"><a href="#9-4-补充说明-¶" class="headerlink" title="9.4. 补充说明 ¶"></a>9.4. 补充说明 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/tutorial/classes.html#random-remarks" title="永久链接至标题">¶</a></h2><p>如果同样的属性名称同时出现在实例和类中，则属性查找会优先选择实例:</p>
<blockquote>
</blockquote>
<figure class="highlight python-repl"><table><tr><td class="code"><pre><code class="hljs python-repl"><span class="hljs-meta">&gt;&gt;&gt;</span> <span class="python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Warehouse</span>:</span>        purpose = <span class="hljs-string">&#x27;storage&#x27;</span>        region = <span class="hljs-string">&#x27;west&#x27;</span>&gt;&gt;&gt; w1 = Warehouse()&gt;&gt;&gt; <span class="hljs-built_in">print</span>(w1.purpose, w1.region)storage west&gt;&gt;&gt; w2 = Warehouse()&gt;&gt;&gt; w2.region = <span class="hljs-string">&#x27;east&#x27;</span>&gt;&gt;&gt; <span class="hljs-built_in">print</span>(w2.purpose, w2.region)storage east</span><br></code></pre></td></tr></table></figure>

<p>数据属性可以被方法以及一个对象的普通用户（“客户端”）所引用。 换句话说，类不能用于实现纯抽象数据类型。 实际上，在 Python 中没有任何东西能强制隐藏数据 — 它是完全基于约定的。 （而在另一方面，用 C 语言编写的 Python 实现则可以完全隐藏实现细节，并在必要时控制对象的访问；此特性可以通过用 C 编写 Python 扩展来使用。）</p>
<p>客户端应当谨慎地使用数据属性 — 客户端可能通过直接操作数据属性的方式破坏由方法所维护的固定变量。 请注意客户端可以向一个实例对象添加他们自己的数据属性而不会影响方法的可用性，只要保证避免名称冲突 — 再次提醒，在此使用命名约定可以省去许多令人头痛的麻烦。</p>
<p>在方法内部引用数据属性（或其他方法！）并没有简便方式。 我发现这实际上提升了方法的可读性：当浏览一个方法代码时，不会存在混淆局部变量和实例变量的机会。</p>
<p>方法的第一个参数常常被命名为 <code>self</code>。 这也不过就是一个约定: <code>self</code> 这一名称在 Python 中绝对没有特殊含义。 但是要注意，不遵循此约定会使得你的代码对其他 Python 程序员来说缺乏可读性，而且也可以想像一个 <em>类浏览器</em> 程序的编写可能会依赖于这样的约定。</p>
<p>任何一个作为类属性的函数都为该类的实例定义了一个相应方法。 函数定义的文本并非必须包含于类定义之内：将一个函数对象赋值给一个局部变量也是可以的。 例如:</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><code class="hljs angelscript"># Function defined outside the classdef f1(self, x, y):    <span class="hljs-keyword">return</span> min(x, x+y)<span class="hljs-keyword">class</span> <span class="hljs-symbol">C:    <span class="hljs-symbol">f</span></span> = <span class="hljs-symbol">f1</span>    <span class="hljs-symbol">def</span> <span class="hljs-symbol">g</span>(<span class="hljs-symbol">self</span>):        <span class="hljs-symbol">return</span> &#x27;<span class="hljs-symbol">hello</span> <span class="hljs-symbol">world</span>&#x27;    <span class="hljs-symbol">h</span> = <span class="hljs-symbol">g</span><br></code></pre></td></tr></table></figure>

<p>现在 <code>f</code>, <code>g</code> 和 <code>h</code> 都是 <code>C</code> 类的引用函数对象的属性，因而它们就都是 <code>C</code> 的实例的方法 — 其中 <code>h</code> 完全等同于 <code>g</code>。 但请注意，本示例的做法通常只会令程序的阅读者感到迷惑。</p>
<p>方法可以通过使用 <code>self</code> 参数的方法属性调用其他方法:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Bag</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self</span>):</span>        self.data = []    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">add</span>(<span class="hljs-params">self, x</span>):</span>        self.data.append(x)    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">addtwice</span>(<span class="hljs-params">self, x</span>):</span>        self.add(x)        self.add(x)<br></code></pre></td></tr></table></figure>

<p>方法可以通过与普通函数相同的方式引用全局名称。 与方法相关联的全局作用域就是包含其定义的模块。 （类永远不会被作为全局作用域。） 虽然我们很少会有充分的理由在方法中使用全局作用域，但全局作用域存在许多合理的使用场景：举个例子，导入到全局作用域的函数和模块可以被方法所使用，在其中定义的函数和类也一样。 通常，包含该方法的类本身是在全局作用域中定义的，而在下一节中我们将会发现为何方法需要引用其所属类的很好的理由。</p>
<p>每个值都是一个对象，因此具有 <em>类</em> （也称为 _类型_），并存储为 <code>object.__class__</code> 。</p>
<h2 id="9-5-继承-¶"><a href="#9-5-继承-¶" class="headerlink" title="9.5. 继承 ¶"></a>9.5. 继承 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/tutorial/classes.html#inheritance" title="永久链接至标题">¶</a></h2><p>当然，如果不支持继承，语言特性就不值得称为 “类”。派生类定义的语法如下所示:</p>
<figure class="highlight crystal"><table><tr><td class="code"><pre><code class="hljs crystal"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DerivedClassName</span>(<span class="hljs-title">BaseClassName</span>):    &lt;<span class="hljs-title">statement</span>-1&gt;    .    .    .    &lt;<span class="hljs-title">statement</span>-<span class="hljs-title">N</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>名称 <code>BaseClassName</code> 必须定义于包含派生类定义的作用域中。 也允许用其他任意表达式代替基类名称所在的位置。 这有时也可能会用得上，例如，当基类定义在另一个模块中的时候:</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><code class="hljs haskell"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-type">DerivedClassName</span>(<span class="hljs-title">modname</span>.<span class="hljs-type">BaseClassName</span>):</span><br></code></pre></td></tr></table></figure>

<p>派生类定义的执行过程与基类相同。 当构造类对象时，基类会被记住。 此信息将被用来解析属性引用：如果请求的属性在类中找不到，搜索将转往基类中进行查找。 如果基类本身也派生自其他某个类，则此规则将被递归地应用。</p>
<p>派生类的实例化没有任何特殊之处: <code>DerivedClassName()</code> 会创建该类的一个新实例。 方法引用将按以下方式解析：搜索相应的类属性，如有必要将按基类继承链逐步向下查找，如果产生了一个函数对象则方法引用就生效。</p>
<p>派生类可能会重写其基类的方法。 因为方法在调用同一对象的其他方法时没有特殊权限，所以调用同一基类中定义的另一方法的基类方法最终可能会调用覆盖它的派生类的方法。 （对 C++ 程序员的提示：Python 中所有的方法实际上都是 <code>virtual</code> 方法。）</p>
<p>在派生类中的重载方法实际上可能想要扩展而非简单地替换同名的基类方法。 有一种方式可以简单地直接调用基类方法：即调用 <code>BaseClassName.methodname(self, arguments)</code>。 有时这对客户端来说也是有用的。 （请注意仅当此基类可在全局作用域中以 <code>BaseClassName</code> 的名称被访问时方可使用此方式。）</p>
<p>Python 有两个内置函数可被用于继承机制：</p>
<ul>
<li><p>  使用 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/library/functions.html#isinstance" title="isinstance"><code>isinstance()</code></a> 来检查一个实例的类型: <code>isinstance(obj, int)</code> 仅会在 <code>obj.__class__</code> 为 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/library/functions.html#int" title="int"><code>int</code></a> 或某个派生自 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/library/functions.html#int" title="int"><code>int</code></a> 的类时为 <code>True</code>。</p>
</li>
<li><p>  使用 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/library/functions.html#issubclass" title="issubclass"><code>issubclass()</code></a> 来检查类的继承关系: <code>issubclass(bool, int)</code> 为 <code>True</code>，因为 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/library/functions.html#bool" title="bool"><code>bool</code></a> 是 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/library/functions.html#int" title="int"><code>int</code></a> 的子类。 但是，<code>issubclass(float, int)</code> 为 <code>False</code>，因为 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/library/functions.html#float" title="float"><code>float</code></a> 不是 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/library/functions.html#int" title="int"><code>int</code></a> 的子类。</p>
</li>
</ul>
<h3 id="9-5-1-多重继承-¶"><a href="#9-5-1-多重继承-¶" class="headerlink" title="9.5.1. 多重继承 ¶"></a>9.5.1. 多重继承 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/tutorial/classes.html#multiple-inheritance" title="永久链接至标题">¶</a></h3><p>Python 也支持一种多重继承。 带有多个基类的类定义语句如下所示:</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><code class="hljs haskell"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-type">DerivedClassName</span>(<span class="hljs-type">Base1</span>, <span class="hljs-type">Base2</span>, <span class="hljs-type">Base3</span>):    &lt;statement-1&gt;    .    .    .    &lt;statement-<span class="hljs-type">N</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>对于多数应用来说，在最简单的情况下，你可以认为搜索从父类所继承属性的操作是深度优先、从左至右的，当层次结构中存在重叠时不会在同一个类中搜索两次。 因此，如果某一属性在 <code>DerivedClassName</code> 中未找到，则会到 <code>Base1</code> 中搜索它，然后（递归地）到 <code>Base1</code> 的基类中搜索，如果在那里未找到，再到 <code>Base2</code> 中搜索，依此类推。</p>
<p>真实情况比这个更复杂一些；方法解析顺序会动态改变以支持对 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/library/functions.html#super" title="super"><code>super()</code></a> 的协同调用。 这种方式在某些其他多重继承型语言中被称为后续方法调用，它比单继承型语言中的 super 调用更强大。</p>
<p>动态改变顺序是有必要的，因为所有多重继承的情况都会显示出一个或更多的菱形关联（即至少有一个父类可通过多条路径被最底层类所访问）。 例如，所有类都是继承自 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/library/functions.html#object" title="object"><code>object</code></a>，因此任何多重继承的情况都提供了一条以上的路径可以通向 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/library/functions.html#object" title="object"><code>object</code></a>。 为了确保基类不会被访问一次以上，动态算法会用一种特殊方式将搜索顺序线性化， 保留每个类所指定的从左至右的顺序，只调用每个父类一次，并且保持单调（即一个类可以被子类化而不影响其父类的优先顺序）。 总而言之，这些特性使得设计具有多重继承的可靠且可扩展的类成为可能。 要了解更多细节，请参阅 <a target="_blank" rel="noopener" href="https://www.python.org/download/releases/2.3/mro/">https://www.python.org/download/releases/2.3/mro/</a>。</p>
<h2 id="9-6-私有变量-¶"><a href="#9-6-私有变量-¶" class="headerlink" title="9.6. 私有变量 ¶"></a>9.6. 私有变量 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/tutorial/classes.html#private-variables" title="永久链接至标题">¶</a></h2><p>那种仅限从一个对象内部访问的 “私有” 实例变量在 Python 中并不存在。 但是，大多数 Python 代码都遵循这样一个约定：带有一个下划线的名称 (例如 <code>_spam</code>) 应该被当作是 API 的非公有部分 (无论它是函数、方法或是数据成员)。 这应当被视为一个实现细节，可能不经通知即加以改变。</p>
<p>由于存在对于类私有成员的有效使用场景（例如避免名称与子类所定义的名称相冲突），因此存在对此种机制的有限支持，称为 _名称改写_。 任何形式为 <code>__spam</code> 的标识符（至少带有两个前缀下划线，至多一个后缀下划线）的文本将被替换为 <code>_classname__spam</code>，其中 <code>classname</code> 为去除了前缀下划线的当前类名称。 这种改写不考虑标识符的句法位置，只要它出现在类定义内部就会进行。</p>
<p>名称改写有助于让子类重载方法而不破坏类内方法调用。例如:</p>
<figure class="highlight n1ql"><table><tr><td class="code"><pre><code class="hljs n1ql">class Mapping:    def __init__(self, iterable):        self.items_list = []        self.__update(iterable)    def <span class="hljs-keyword">update</span>(<span class="hljs-keyword">self</span>, iterable):        <span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> iterable:            <span class="hljs-keyword">self</span>.items_list.append(item)    __update = <span class="hljs-keyword">update</span>   # <span class="hljs-keyword">private</span> copy of original <span class="hljs-keyword">update</span>() methodclass MappingSubclass(<span class="hljs-keyword">Mapping</span>):    def <span class="hljs-keyword">update</span>(<span class="hljs-keyword">self</span>, <span class="hljs-keyword">keys</span>, <span class="hljs-keyword">values</span>):        # provides new signature <span class="hljs-keyword">for</span> <span class="hljs-keyword">update</span>()        # but does <span class="hljs-keyword">not</span> <span class="hljs-keyword">break</span> __init__()        <span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> zip(<span class="hljs-keyword">keys</span>, <span class="hljs-keyword">values</span>):            <span class="hljs-keyword">self</span>.items_list.append(item)<br></code></pre></td></tr></table></figure>

<p>上面的示例即使在 <code>MappingSubclass</code> 引入了一个 <code>__update</code> 标识符的情况下也不会出错，因为它会在 <code>Mapping</code> 类中被替换为 <code>_Mapping__update</code> 而在 <code>MappingSubclass</code> 类中被替换为 <code>_MappingSubclass__update</code>。</p>
<p>请注意，改写规则的设计主要是为了避免意外冲突；访问或修改被视为私有的变量仍然是可能的。这在特殊情况下甚至会很有用，例如在调试器中。</p>
<p>请注意传递给 <code>exec()</code> 或 <code>eval()</code> 的代码不会将发起调用类的类名视作当前类；这类似于 <code>global</code> 语句的效果，因此这种效果仅限于同时经过字节码编译的代码。 同样的限制也适用于 <code>getattr()</code>, <code>setattr()</code> 和 <code>delattr()</code>，以及对于 <code>__dict__</code> 的直接引用。</p>
<h2 id="9-7-杂项说明-¶"><a href="#9-7-杂项说明-¶" class="headerlink" title="9.7. 杂项说明 ¶"></a>9.7. 杂项说明 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/tutorial/classes.html#odds-and-ends" title="永久链接至标题">¶</a></h2><p>有时会需要使用类似于 Pascal 的 “record” 或 C 的 “struct” 这样的数据类型，将一些命名数据项捆绑在一起。 这种情况适合定义一个空类:</p>
<figure class="highlight oxygene"><table><tr><td class="code"><pre><code class="hljs oxygene"><span class="hljs-keyword">class</span> Employee:    passjohn = Employee()  # <span class="hljs-keyword">Create</span> an <span class="hljs-keyword">empty</span> employee <span class="hljs-keyword">record</span># Fill the fields <span class="hljs-keyword">of</span> the recordjohn.name = <span class="hljs-string">&#x27;John Doe&#x27;</span>john.dept = <span class="hljs-string">&#x27;computer lab&#x27;</span>john.salary = <span class="hljs-number">1000</span><br></code></pre></td></tr></table></figure>

<p>一段需要特定抽象数据类型的 Python 代码往往可以被传入一个模拟了该数据类型的方法的类作为替代。 例如，如果你有一个基于文件对象来格式化某些数据的函数，你可以定义一个带有 <code>read()</code> 和 <code>readline()</code> 方法从字符串缓存获取数据的类，并将其作为参数传入。</p>
<p>实例方法对象也具有属性: <code>m.__self__</code> 就是带有 <code>m()</code> 方法的实例对象，而 <code>m.__func__</code> 则是该方法所对应的函数对象。</p>
<h2 id="9-8-迭代器-¶"><a href="#9-8-迭代器-¶" class="headerlink" title="9.8. 迭代器 ¶"></a>9.8. 迭代器 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/tutorial/classes.html#iterators" title="永久链接至标题">¶</a></h2><p>到目前为止，您可能已经注意到大多数容器对象都可以使用 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/reference/compound_stmts.html#for"><code>for</code></a> 语句:</p>
<figure class="highlight processing"><table><tr><td class="code"><pre><code class="hljs processing"><span class="hljs-keyword">for</span> element in [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]:    <span class="hljs-built_in">print</span>(element)<span class="hljs-keyword">for</span> element in (<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>):    <span class="hljs-built_in">print</span>(element)<span class="hljs-keyword">for</span> <span class="hljs-built_in">key</span> in &#123;<span class="hljs-string">&#x27;one&#x27;</span>:<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;two&#x27;</span>:<span class="hljs-number">2</span>&#125;:    <span class="hljs-built_in">print</span>(<span class="hljs-built_in">key</span>)<span class="hljs-keyword">for</span> <span class="hljs-built_in">char</span> in <span class="hljs-string">&quot;123&quot;</span>:    <span class="hljs-built_in">print</span>(<span class="hljs-built_in">char</span>)<span class="hljs-keyword">for</span> <span class="hljs-built_in">line</span> in <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;myfile.txt&quot;</span>):    <span class="hljs-built_in">print</span>(<span class="hljs-built_in">line</span>, end=<span class="hljs-string">&#x27;&#x27;</span>)<br></code></pre></td></tr></table></figure>

<p>这种访问风格清晰、简洁又方便。 迭代器的使用非常普遍并使得 Python 成为一个统一的整体。 在幕后，<a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/reference/compound_stmts.html#for"><code>for</code></a> 语句会在容器对象上调用 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/library/functions.html#iter" title="iter"><code>iter()</code></a>。 该函数返回一个定义了 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/library/stdtypes.html#iterator.__next__" title="iterator.__next__"><code>__next__()</code></a> 方法的迭代器对象，此方法将逐一访问容器中的元素。 当元素用尽时，<a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/library/stdtypes.html#iterator.__next__" title="iterator.__next__"><code>__next__()</code></a> 将引发 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/library/exceptions.html#StopIteration" title="StopIteration"><code>StopIteration</code></a> 异常来通知终止 <code>for</code> 循环。 你可以使用 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/library/functions.html#next" title="next"><code>next()</code></a> 内置函数来调用 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/library/stdtypes.html#iterator.__next__" title="iterator.__next__"><code>__next__()</code></a> 方法；这个例子显示了它的运作方式:</p>
<blockquote>
</blockquote>
<figure class="highlight livecodeserver"><table><tr><td class="code"><pre><code class="hljs livecodeserver">&gt;&gt;&gt; s = <span class="hljs-string">&#x27;abc&#x27;</span>&gt;&gt;&gt; <span class="hljs-keyword">it</span> = iter(s)&gt;&gt;&gt; <span class="hljs-keyword">it</span>&lt;iterator object <span class="hljs-keyword">at</span> <span class="hljs-number">0x00A1DB50</span>&gt;&gt;&gt;&gt; next(<span class="hljs-keyword">it</span>)<span class="hljs-string">&#x27;a&#x27;</span>&gt;&gt;&gt; next(<span class="hljs-keyword">it</span>)<span class="hljs-string">&#x27;b&#x27;</span>&gt;&gt;&gt; next(<span class="hljs-keyword">it</span>)<span class="hljs-string">&#x27;c&#x27;</span>&gt;&gt;&gt; next(<span class="hljs-keyword">it</span>)Traceback (most recent call <span class="hljs-keyword">last</span>):  File <span class="hljs-string">&quot;&lt;stdin&gt;&quot;</span>, <span class="hljs-built_in">line</span> <span class="hljs-number">1</span>, <span class="hljs-keyword">in</span> &lt;module&gt;    next(<span class="hljs-keyword">it</span>)StopIteration<br></code></pre></td></tr></table></figure>

<p>看过迭代器协议的幕后机制，给你的类添加迭代器行为就很容易了。 定义一个 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/reference/datamodel.html#object.__iter__" title="object.__iter__"><code>__iter__()</code></a> 方法来返回一个带有 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/library/stdtypes.html#iterator.__next__" title="iterator.__next__"><code>__next__()</code></a> 方法的对象。 如果类已定义了 <code>__next__()</code>，则 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/reference/datamodel.html#object.__iter__" title="object.__iter__"><code>__iter__()</code></a> 可以简单地返回 <code>self</code>:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Reverse</span>:</span>    <span class="hljs-string">&quot;&quot;&quot;Iterator for looping over a sequence backwards.&quot;&quot;&quot;</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, data</span>):</span>        self.data = data        self.index = <span class="hljs-built_in">len</span>(data)    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__iter__</span>(<span class="hljs-params">self</span>):</span>        <span class="hljs-keyword">return</span> self    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__next__</span>(<span class="hljs-params">self</span>):</span>        <span class="hljs-keyword">if</span> self.index == <span class="hljs-number">0</span>:            <span class="hljs-keyword">raise</span> StopIteration        self.index = self.index - <span class="hljs-number">1</span>        <span class="hljs-keyword">return</span> self.data[self.index]<br></code></pre></td></tr></table></figure>

<blockquote>
</blockquote>
<figure class="highlight gradle"><table><tr><td class="code"><pre><code class="hljs gradle">&gt;&gt;&gt; rev = <span class="hljs-keyword">Reverse</span>(<span class="hljs-string">&#x27;spam&#x27;</span>)&gt;&gt;&gt; iter(rev)&lt;__main__.<span class="hljs-keyword">Reverse</span> object at <span class="hljs-number">0</span>x00A1DB50&gt;&gt;&gt;&gt; <span class="hljs-keyword">for</span> <span class="hljs-keyword">char</span> in rev:...     <span class="hljs-keyword">print</span>(<span class="hljs-keyword">char</span>)...maps<br></code></pre></td></tr></table></figure>

<h2 id="9-9-生成器-¶"><a href="#9-9-生成器-¶" class="headerlink" title="9.9. 生成器 ¶"></a>9.9. 生成器 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/tutorial/classes.html#generators" title="永久链接至标题">¶</a></h2><p><a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/glossary.html#term-generator">生成器</a> 是一个用于创建迭代器的简单而强大的工具。 它们的写法类似于标准的函数，但当它们要返回数据时会使用 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/reference/simple_stmts.html#yield"><code>yield</code></a> 语句。 每次在生成器上调用 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/library/functions.html#next" title="next"><code>next()</code></a> 时，它会从上次离开的位置恢复执行（它会记住上次执行语句时的所有数据值）。 一个显示如何非常容易地创建生成器的示例如下:</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><code class="hljs fortran">def reverse(<span class="hljs-keyword">data</span>):    for <span class="hljs-built_in">index</span> <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(len(<span class="hljs-keyword">data</span>)-<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>):        yield <span class="hljs-keyword">data</span>[<span class="hljs-built_in">index</span>]<br></code></pre></td></tr></table></figure>

<blockquote>
</blockquote>
<figure class="highlight axapta"><table><tr><td class="code"><pre><code class="hljs axapta">&gt;&gt;&gt; <span class="hljs-keyword">for</span> <span class="hljs-built_in">char</span> <span class="hljs-keyword">in</span> <span class="hljs-keyword">reverse</span>(<span class="hljs-string">&#x27;golf&#x27;</span>):...     <span class="hljs-keyword">print</span>(<span class="hljs-built_in">char</span>)...flog<br></code></pre></td></tr></table></figure>

<p>可以用生成器来完成的操作同样可以用前一节所描述的基于类的迭代器来完成。 但生成器的写法更为紧凑，因为它会自动创建 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/reference/datamodel.html#object.__iter__" title="object.__iter__"><code>__iter__()</code></a> 和 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/reference/expressions.html#generator.__next__" title="generator.__next__"><code>__next__()</code></a> 方法。</p>
<p>另一个关键特性在于局部变量和执行状态会在每次调用之间自动保存。 这使得该函数相比使用 <code>self.index</code> 和 <code>self.data</code> 这种实例变量的方式更易编写且更为清晰。</p>
<p>除了会自动创建方法和保存程序状态，当生成器终结时，它们还会自动引发 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/library/exceptions.html#StopIteration" title="StopIteration"><code>StopIteration</code></a>。 这些特性结合在一起，使得创建迭代器能与编写常规函数一样容易。</p>
<h2 id="9-10-生成器表达式-¶"><a href="#9-10-生成器表达式-¶" class="headerlink" title="9.10. 生成器表达式 ¶"></a>9.10. 生成器表达式 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/tutorial/classes.html#generator-expressions" title="永久链接至标题">¶</a></h2><p>某些简单的生成器可以写成简洁的表达式代码，所用语法类似列表推导式，但外层为圆括号而非方括号。 这种表达式被设计用于生成器将立即被外层函数所使用的情况。 生成器表达式相比完整的生成器更紧凑但较不灵活，相比等效的列表推导式则更为节省内存。</p>
<p>例如:</p>
<blockquote>
</blockquote>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><code class="hljs pgsql">&gt;&gt;&gt; sum(i*i <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">10</span>))                 # sum <span class="hljs-keyword">of</span> squares&gt;&gt;&gt; xvec = [<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">30</span>]&gt;&gt;&gt; yvec = [<span class="hljs-number">7</span>, <span class="hljs-number">5</span>, <span class="hljs-number">3</span>]&gt;&gt;&gt; sum(x*y <span class="hljs-keyword">for</span> x,y <span class="hljs-keyword">in</span> zip(xvec, yvec))         # dot product&gt;&gt;&gt; unique_words = <span class="hljs-keyword">set</span>(word <span class="hljs-keyword">for</span> <span class="hljs-type">line</span> <span class="hljs-keyword">in</span> page  <span class="hljs-keyword">for</span> word <span class="hljs-keyword">in</span> <span class="hljs-type">line</span>.split())&gt;&gt;&gt; valedictorian = max((student.gpa, student.name) <span class="hljs-keyword">for</span> student <span class="hljs-keyword">in</span> graduates)&gt;&gt;&gt; data = <span class="hljs-string">&#x27;golf&#x27;</span>&gt;&gt;&gt; list(data[i] <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(len(data)<span class="hljs-number">-1</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">-1</span>))[<span class="hljs-string">&#x27;f&#x27;</span>, <span class="hljs-string">&#x27;l&#x27;</span>, <span class="hljs-string">&#x27;o&#x27;</span>, <span class="hljs-string">&#x27;g&#x27;</span>]<br></code></pre></td></tr></table></figure>

<p>脚注</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="http://example.com">wkless</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="http://example.com/post/d2f57d73.html">http://example.com/post/d2f57d73.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/python/">python</a></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdelivr.net/gh/wklesss/picture@latest/img/photo-1526379095098-d400fd0bf935" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/gh/overtrue/share.js@master/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/post/20e858c0.html"><img class="prev-cover" src="https://cdn.jsdelivr.net/gh/wklesss/picture@latest/img/20210603112347.jfif" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">Previous Post</div><div class="prev_info">【study note】vim</div></div></a></div><div class="next-post pull-right"><a href="/post/48e7fa72.html"><img class="next-cover" src="https://cdn.jsdelivr.net/gh/wklesss/picture@latest/img/photo-1556075798-4825dfaaf498" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">Next Post</div><div class="next_info">github简明教程</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>Related Articles</span></div><div class="relatedPosts-list"><div><a href="/post/3383b2ac.html" title="Conda使用指南"><img class="cover" src="https://cdn.jsdelivr.net/gh/wklesss/picture@latest/img/photo-1577375729152-4c8b5fcda381" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-07-27</div><div class="title">Conda使用指南</div></div></a></div><div><a href="/post/324e8246.html" title="linux安装python3.9"><img class="cover" src="https://cdn.jsdelivr.net/gh/wklesss/picture@latest/img/20210702105845.jpeg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-07-02</div><div class="title">linux安装python3.9</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://s2.loli.net/2022/06/09/6WAnYe4pymBI5xP.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">wkless</div><div class="author-info__description">学习记录网站</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">21</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">36</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">3</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>Announcement</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Catalog</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#9-1-%E5%90%8D%E7%A7%B0%E5%92%8C%E5%AF%B9%E8%B1%A1-%C2%B6"><span class="toc-number">1.</span> <span class="toc-text">9.1. 名称和对象 </span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-2-Python-%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4-%C2%B6"><span class="toc-number">2.</span> <span class="toc-text">9.2. Python 作用域和命名空间 </span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#9-2-1-%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E7%A4%BA%E4%BE%8B-%C2%B6"><span class="toc-number">2.1.</span> <span class="toc-text">9.2.1. 作用域和命名空间示例 </span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-3-%E5%88%9D%E6%8E%A2%E7%B1%BB-%C2%B6"><span class="toc-number">3.</span> <span class="toc-text">9.3. 初探类 </span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#9-3-1-%E7%B1%BB%E5%AE%9A%E4%B9%89%E8%AF%AD%E6%B3%95-%C2%B6"><span class="toc-number">3.1.</span> <span class="toc-text">9.3.1. 类定义语法 </span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-3-2-%E7%B1%BB%E5%AF%B9%E8%B1%A1-%C2%B6"><span class="toc-number">3.2.</span> <span class="toc-text">9.3.2. 类对象 </span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-3-3-%E5%AE%9E%E4%BE%8B%E5%AF%B9%E8%B1%A1-%C2%B6"><span class="toc-number">3.3.</span> <span class="toc-text">9.3.3. 实例对象 </span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-3-4-%E6%96%B9%E6%B3%95%E5%AF%B9%E8%B1%A1-%C2%B6"><span class="toc-number">3.4.</span> <span class="toc-text">9.3.4. 方法对象 </span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-3-5-%E7%B1%BB%E5%92%8C%E5%AE%9E%E4%BE%8B%E5%8F%98%E9%87%8F-%C2%B6"><span class="toc-number">3.5.</span> <span class="toc-text">9.3.5. 类和实例变量 </span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-4-%E8%A1%A5%E5%85%85%E8%AF%B4%E6%98%8E-%C2%B6"><span class="toc-number">4.</span> <span class="toc-text">9.4. 补充说明 </span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-5-%E7%BB%A7%E6%89%BF-%C2%B6"><span class="toc-number">5.</span> <span class="toc-text">9.5. 继承 </span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#9-5-1-%E5%A4%9A%E9%87%8D%E7%BB%A7%E6%89%BF-%C2%B6"><span class="toc-number">5.1.</span> <span class="toc-text">9.5.1. 多重继承 </span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-6-%E7%A7%81%E6%9C%89%E5%8F%98%E9%87%8F-%C2%B6"><span class="toc-number">6.</span> <span class="toc-text">9.6. 私有变量 </span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-7-%E6%9D%82%E9%A1%B9%E8%AF%B4%E6%98%8E-%C2%B6"><span class="toc-number">7.</span> <span class="toc-text">9.7. 杂项说明 </span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-8-%E8%BF%AD%E4%BB%A3%E5%99%A8-%C2%B6"><span class="toc-number">8.</span> <span class="toc-text">9.8. 迭代器 </span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-9-%E7%94%9F%E6%88%90%E5%99%A8-%C2%B6"><span class="toc-number">9.</span> <span class="toc-text">9.9. 生成器 </span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-10-%E7%94%9F%E6%88%90%E5%99%A8%E8%A1%A8%E8%BE%BE%E5%BC%8F-%C2%B6"><span class="toc-number">10.</span> <span class="toc-text">9.10. 生成器表达式 </span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Post</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/post/3b7b10e0.html" title="docker固定内网ip"><img src="https://cdn.jsdelivr.net/gh/wklesss/picture@latest/img/202206091443862.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="docker固定内网ip"/></a><div class="content"><a class="title" href="/post/3b7b10e0.html" title="docker固定内网ip">docker固定内网ip</a><time datetime="2022-06-09T06:53:18.000Z" title="Created 2022-06-09 14:53:18">2022-06-09</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/post/878a097a.html" title="群辉docker配置Joplin Server"><img src="https://cdn.jsdelivr.net/gh/wklesss/picture@latest/img/photo-1527168027773-0cc890c4f42e" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="群辉docker配置Joplin Server"/></a><div class="content"><a class="title" href="/post/878a097a.html" title="群辉docker配置Joplin Server">群辉docker配置Joplin Server</a><time datetime="2021-09-07T08:09:56.000Z" title="Created 2021-09-07 16:09:56">2021-09-07</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/post/82d44a65.html" title="zsh配置"><img src="https://cdn.jsdelivr.net/gh/wklesss/picture@latest/img/photo-1607877361964-bf792b65e593" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="zsh配置"/></a><div class="content"><a class="title" href="/post/82d44a65.html" title="zsh配置">zsh配置</a><time datetime="2021-08-23T09:21:23.000Z" title="Created 2021-08-23 17:21:23">2021-08-23</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/post/3383b2ac.html" title="Conda使用指南"><img src="https://cdn.jsdelivr.net/gh/wklesss/picture@latest/img/photo-1577375729152-4c8b5fcda381" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Conda使用指南"/></a><div class="content"><a class="title" href="/post/3383b2ac.html" title="Conda使用指南">Conda使用指南</a><time datetime="2021-07-27T13:02:36.000Z" title="Created 2021-07-27 21:02:36">2021-07-27</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/post/fef49edf.html" title="wsl2固定ip方案"><img src="https://cdn.jsdelivr.net/gh/wklesss/picture@latest/img/photo-1563089145-599997674d42" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="wsl2固定ip方案"/></a><div class="content"><a class="title" href="/post/fef49edf.html" title="wsl2固定ip方案">wsl2固定ip方案</a><time datetime="2021-07-27T12:13:46.000Z" title="Created 2021-07-27 20:13:46">2021-07-27</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2022 By wkless</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Read Mode"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="Toggle Between Light And Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle between single-column and double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="Setting"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table Of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back To Top"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>