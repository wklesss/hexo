<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>kk</title>
  
  <subtitle>wkless&#39;blog</subtitle>
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2022-06-09T06:54:55.915Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>wkless</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>docker固定内网ip</title>
    <link href="http://example.com/post/3b7b10e0.html"/>
    <id>http://example.com/post/3b7b10e0.html</id>
    <published>2022-06-09T06:53:18.000Z</published>
    <updated>2022-06-09T06:54:55.915Z</updated>
    
    <content type="html"><![CDATA[<h1 id="docker固定内网ip，分离代理，解决pt走代理的问题"><a href="#docker固定内网ip，分离代理，解决pt走代理的问题" class="headerlink" title="docker固定内网ip，分离代理，解决pt走代理的问题"></a>docker固定内网ip，分离代理，解决pt走代理的问题</h1><h2 id="创建网络"><a href="#创建网络" class="headerlink" title="创建网络"></a>创建网络</h2><p>服务器或nas通过ssh登录，<code>sudo -i</code>取得root权限，输入以下命令：</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">docker network create -d macvlan --subnet=192.168.1.0/24 --gateway=192.168.1.2 -o parent=ovs_eth0 bridge-host<br></code></pre></td></tr></table></figure><p>其中:</p><p><code>macvlan</code>：驱动</p><p><code>subnet=192.168.1.0/24</code> ：网段</p><p><code>gateway=192.168.1.2</code>：网关地址</p><p><code>parent=ovs_eth0</code>：物理网卡名称，可通过 <code>ip addr</code>查询</p><p><code>bridge-host</code>：自定义网络名称</p><h2 id="创建容器"><a href="#创建容器" class="headerlink" title="创建容器"></a>创建容器</h2><h3 id="docker-run"><a href="#docker-run" class="headerlink" title="docker run"></a>docker run</h3><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">docker run -itd --name tr --network bridge-host --ip=192.168.1.15 chisbread/transmission:latest<br></code></pre></td></tr></table></figure><h3 id="docker-compose"><a href="#docker-compose" class="headerlink" title="docker-compose"></a>docker-compose</h3><figure class="highlight dockerfile"><table><tr><td class="code"><pre><code class="hljs dockerfile">version: <span class="hljs-string">&quot;3&quot;</span><br>services:<br>  tr-bz:<br>    image: chisbread/transmission:latest<br>    container_name: tr-bz <br>    restart: unless-stopped<br>    networks:<br>      default:<br>        ipv4_address: <span class="hljs-number">192.168</span>.<span class="hljs-number">1.15</span><br>    environment:<br>      - PUID=<span class="hljs-number">1026</span><br>      - PGID=<span class="hljs-number">100</span> <br>      - TZ=Asia/Shanghai<br>      - <span class="hljs-keyword">USER</span>=admin<br>      - PASS=admin<br>      - PEERPORT=<span class="hljs-number">51413</span><br>      - RPCPORT=<span class="hljs-number">12005</span><br>    volumes:<br>      - <br>      <br>networks:<br>  default:<br>    external:<br>      name: bridge-host<br><br></code></pre></td></tr></table></figure><p>这样就可以将自定义网络中的网关地址修改为主路由地址，并分配独立的ip，防止不需要走代理的容器在旁路由内出现各种问题</p><blockquote><p>参考：</p><p><a href="https://www.gitloc.com/archives/82.html">群晖docker安装宝塔面板并启用独立内网ip</a></p><p><a href="https://www.cnblogs.com/nnylee/p/11428567.html">docker-compose 使用自定义网络并绑定 IP</a></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;docker固定内网ip，分离代理，解决pt走代理的问题&quot;&gt;&lt;a href=&quot;#docker固定内网ip，分离代理，解决pt走代理的问题&quot; class=&quot;headerlink&quot; title=&quot;docker固定内网ip，分离代理，解决pt走代理的问题&quot;&gt;&lt;/a&gt;do</summary>
      
    
    
    
    <category term="工具使用" scheme="http://example.com/categories/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/"/>
    
    
    <category term="linux" scheme="http://example.com/tags/linux/"/>
    
    <category term="docker" scheme="http://example.com/tags/docker/"/>
    
    <category term="terminal" scheme="http://example.com/tags/terminal/"/>
    
    <category term="pt" scheme="http://example.com/tags/pt/"/>
    
    <category term="shell" scheme="http://example.com/tags/shell/"/>
    
  </entry>
  
  <entry>
    <title>群辉docker配置Joplin Server</title>
    <link href="http://example.com/post/878a097a.html"/>
    <id>http://example.com/post/878a097a.html</id>
    <published>2021-09-07T08:09:56.000Z</published>
    <updated>2022-06-09T07:09:39.301Z</updated>
    
    <content type="html"><![CDATA[<h1 id="群辉Docker配置Joplin-Server"><a href="#群辉Docker配置Joplin-Server" class="headerlink" title="群辉Docker配置Joplin Server"></a>群辉Docker配置Joplin Server</h1><h2 id="创建目录、文件"><a href="#创建目录、文件" class="headerlink" title="创建目录、文件"></a>创建目录、文件</h2><ol><li><p>此步骤在docker文件操作目录下进行</p><p><code>mkdir joplin</code> </p><p><code>cd joplin</code></p></li><li><p>创建 docker-compose.yml 文件<br><code>vim docker-compose.yml</code>#或者用其他你喜欢的编辑器</p></li></ol><figure class="highlight routeros"><table><tr><td class="code"><pre><code class="hljs routeros">version: <span class="hljs-string">&#x27;3&#x27;</span><br>services:<br>    db:<br>        image: postgres:13.1<br>        ports:<br>            - <span class="hljs-string">&quot;54321:5432&quot;</span> #群辉系统postgres已占用5432端口，这里需要将5432映射到其他端口<br>        restart: unless-stopped<br>        environment:<br>            - <span class="hljs-attribute">APP_PORT</span>=22300<br>            - <span class="hljs-attribute">POSTGRES_PASSWORD</span>=password #密码<br>            - <span class="hljs-attribute">POSTGRES_USER</span>=user<br>            - <span class="hljs-attribute">POSTGRES_DB</span>=joplin<br>    app:<br>        image: joplin/server:latest<br>        depends_on:<br>            - db<br>        ports:<br>            - <span class="hljs-string">&quot;22300:22300&quot;</span><br>        restart: unless-stopped<br>        environment:<br>            - <span class="hljs-attribute">APP_BASE_URL</span>=http://你的域名/<br>            - <span class="hljs-attribute">DB_CLIENT</span>=pg<br>            - <span class="hljs-attribute">POSTGRES_PASSWORD</span>=密码<br>            - <span class="hljs-attribute">POSTGRES_DATABASE</span>=joplin<br>            - <span class="hljs-attribute">POSTGRES_USER</span>=user<br>            - <span class="hljs-attribute">POSTGRES_PORT</span>=5432<br>            - <span class="hljs-attribute">POSTGRES_HOST</span>=db<br></code></pre></td></tr></table></figure><h2 id="创建容器"><a href="#创建容器" class="headerlink" title="创建容器"></a>创建容器</h2><p><code>docker-compose up -d</code></p><p>此处将创建joplin_app_1、joplin_db_1两个容器。</p><p><img src="https://cdn.jsdelivr.net/gh/wklesss/picture@latest/img/image-20210907162256407.png" alt="image-20210907162256407"></p><h2 id="管理"><a href="#管理" class="headerlink" title="管理"></a>管理</h2><p>浏览器使用<a href="http://你的域名/">http://你的域名/</a>进入管理页面</p><p>首次登陆邮箱为：admin@localhost 密码为：admin</p><p>成功进入管理页面</p><img src="https://cdn.jsdelivr.net/gh/wklesss/picture@latest/img/image-20210907163105367.png" alt="image-20210907163105367" style="zoom:80%;" /><p>点击user按钮，在账户管理页面修改email以及password</p><h2 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h2><ol><li>joplin进入设置 <kbd>Ctrl</kbd>+<kbd>，</kbd> </li><li>同步选项：<ul><li>同步目标：Joplin Server (Beta)</li><li>Joplin 服务器 URL: http://你的域名/</li><li>Joplin Server 邮箱：你的管理页面邮箱</li><li>Joplin 服务器密码：你的管理员邮箱</li></ul></li></ol><img src="https://cdn.jsdelivr.net/gh/wklesss/picture@latest/img/image-20210907163411965.png" alt="image-20210907163411965" style="zoom:80%;" />]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;群辉Docker配置Joplin-Server&quot;&gt;&lt;a href=&quot;#群辉Docker配置Joplin-Server&quot; class=&quot;headerlink&quot; title=&quot;群辉Docker配置Joplin Server&quot;&gt;&lt;/a&gt;群辉Docker配置Joplin </summary>
      
    
    
    
    <category term="工具使用" scheme="http://example.com/categories/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/"/>
    
    
    <category term="docker" scheme="http://example.com/tags/docker/"/>
    
    <category term="群辉" scheme="http://example.com/tags/%E7%BE%A4%E8%BE%89/"/>
    
    <category term="nas" scheme="http://example.com/tags/nas/"/>
    
    <category term="joplin" scheme="http://example.com/tags/joplin/"/>
    
    <category term="剪藏" scheme="http://example.com/tags/%E5%89%AA%E8%97%8F/"/>
    
    <category term="笔记" scheme="http://example.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>zsh配置</title>
    <link href="http://example.com/post/82d44a65.html"/>
    <id>http://example.com/post/82d44a65.html</id>
    <published>2021-08-23T09:21:23.000Z</published>
    <updated>2022-06-09T07:09:39.300Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>环境为wsl-ubuntu18</p><p><img src="https://cdn.jsdelivr.net/gh/wklesss/picture@latest/img/image-20210907170638965.png" alt="image-20210907170638965"></p></blockquote><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p><code>sudo apt update &amp;&amp;  sudo apt upgrade</code></p><h2 id="zsh安装"><a href="#zsh安装" class="headerlink" title="zsh安装"></a>zsh安装</h2><p>在安装 oh-my-zsh 之前，首先需要安装好<code>zsh</code>：</p><figure class="highlight cmake"><table><tr><td class="code"><pre><code class="hljs cmake">apt <span class="hljs-keyword">install</span> -y zsh<br></code></pre></td></tr></table></figure><p>切换 shell 为 zsh：</p><figure class="highlight awk"><table><tr><td class="code"><pre><code class="hljs awk">chsh -s <span class="hljs-regexp">/bin/</span>zsh<br></code></pre></td></tr></table></figure><p>重启终端：</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 查看当前shell</span><br><span class="hljs-built_in">echo</span> <span class="hljs-variable">$SHELL</span><br></code></pre></td></tr></table></figure><p>输出<code>/bin/zsh</code>表示成功</p><h2 id="oh-my-zsh安装"><a href="#oh-my-zsh安装" class="headerlink" title="oh-my-zsh安装"></a>oh-my-zsh安装</h2><ul><li><p>Install oh-my-zsh via curl</p></li><li><p> $ <code> sh -c &quot;$(curl -fsSL https://raw.github.com/ohmyzsh/ohmyzsh/master/tools/install.sh)&quot;</code></p></li><li><p>Install oh-my-zsh via wget</p><p>$ <code>sh -c &quot;$(wget https://raw.github.com/ohmyzsh/ohmyzsh/master/tools/install.sh -O -)&quot;</code></p></li></ul><p>安装成功出现如下界面</p><p><img src="https://cdn.jsdelivr.net/gh/wklesss/picture@latest/img/v2-fb93443e858f4fe0a7888a0e8eb8c83c_r.jpg"></p><h2 id="主题配置"><a href="#主题配置" class="headerlink" title="主题配置"></a>主题配置</h2><p><code>oh-my-zsh</code>的主题非常丰富，可以用如下命令查看已有主题：</p><figure class="highlight jboss-cli"><table><tr><td class="code"><pre><code class="hljs jboss-cli"><span class="hljs-keyword">ls</span> <span class="hljs-string">.oh-my-zsh/themes</span><br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/wklesss/picture@latest/img/v2-1716810cbaf0ccf2f9f63c887cbbc148_r.jpg"></p><p>个人比较喜欢简单的，因此用了<code>ys</code>主题，进入<code>.zshrc</code>配置文件进行修改</p><figure class="highlight jboss-cli"><table><tr><td class="code"><pre><code class="hljs jboss-cli">vim ~<span class="hljs-string">/.zshrc</span><br></code></pre></td></tr></table></figure><p>将ZSH_THEME改为<code>ZSH_THEME=&quot;ys&quot;</code>，<code>:wq</code>保存退出</p><p><code>source .zshrc</code>使主题生效</p><h2 id="插件安装"><a href="#插件安装" class="headerlink" title="插件安装"></a>插件安装</h2><h3 id="zsh-autosuggestions"><a href="#zsh-autosuggestions" class="headerlink" title="zsh-autosuggestions"></a>zsh-autosuggestions</h3><p>这是一个命令自动补全插件，当你输入命令的几个字母，它会自动根据历史输入进行自动补全，然后按<code>→</code>，安装也很简单：</p><figure class="highlight awk"><table><tr><td class="code"><pre><code class="hljs awk">git clone https:<span class="hljs-regexp">//gi</span>thub.com<span class="hljs-regexp">/zsh-users/</span>zsh-autosuggestions <span class="hljs-variable">$ZSH_CUSTOM</span><span class="hljs-regexp">/plugins/</span>zsh-autosuggestions<br>vim ~/.zshrc<br><span class="hljs-comment"># 加入插件列表</span><br>plugins=(<br>  git<br>  zsh-autosuggestions<br>)<br>source ~/.zshrc<br></code></pre></td></tr></table></figure><h3 id="zsh-syntax-highlighting"><a href="#zsh-syntax-highlighting" class="headerlink" title="zsh-syntax-highlighting"></a>zsh-syntax-highlighting</h3><p>这个插件的主要作用就是在提高颜值（高亮你的 zsh 可用命令），安装如下：</p><figure class="highlight awk"><table><tr><td class="code"><pre><code class="hljs awk">git clone https:<span class="hljs-regexp">//gi</span>thub.com<span class="hljs-regexp">/zsh-users/</span>zsh-syntax-highlighting.git <span class="hljs-variable">$&#123;ZSH_CUSTOM:-~/.oh-my-zsh/custom&#125;</span><span class="hljs-regexp">/plugins/</span>zsh-syntax-highlighting<br>vim ~/.zshrc<br><span class="hljs-comment"># 加入插件列表</span><br>plugins=(<br>  git<br>  zsh-autosuggestions<br>  zsh-syntax-highlighting<br>)<br>source ~/.zshrc<br></code></pre></td></tr></table></figure><p>效果如下图：</p><p><img src="https://cdn.jsdelivr.net/gh/wklesss/picture@latest/img/v2-c409188909175ad31fe9a1ff15d2b143_r.jpg"></p><h3 id="autojump"><a href="#autojump" class="headerlink" title="autojump"></a>autojump</h3><p>这款插件基本上算是必备插件了，在终端操作里面比较常用的算是文件夹之间的切换，这款插件极大地简化了路径跳转的操作，在一键直达的功能下，自动补全也就一般般了哈</p><p>先安装：</p><figure class="highlight gradle"><table><tr><td class="code"><pre><code class="hljs gradle">apt install autojump-zsh<br>chmod <span class="hljs-number">777</span> <span class="hljs-regexp">/usr/</span>share<span class="hljs-regexp">/autojump/</span>autojump.bash<br>echo <span class="hljs-string">&quot;/usr/share/autojump/autojump.bash&quot;</span> &gt;&gt; ~/.zshrc<br><span class="hljs-keyword">source</span> ~/.zshrc<br></code></pre></td></tr></table></figure><p>效果如下：</p><img src="https://cdn.jsdelivr.net/gh/wklesss/picture@latest/img/v2-fffd39bdd01464f8df7ad17fa6c7ada0_r.jpg" style="zoom:50%;" /><p>以前的<code>cd code</code>现在可以直接<code>j c</code>，路径越长，该插件效果就越明显</p><h3 id="incr"><a href="#incr" class="headerlink" title="incr"></a>incr</h3><p><code>incr</code>是一款自动提示插件，功能非常强大，官网演示 demo，感受一下：</p><img src="https://cdn.jsdelivr.net/gh/wklesss/picture@latest/img/v2-a9a9cc115d4fc56dce323fd3db1e1128_b.gif"  /><p>安装：</p><figure class="highlight awk"><table><tr><td class="code"><pre><code class="hljs awk">wget http:<span class="hljs-regexp">//mim</span>osa-pudica.net<span class="hljs-regexp">/src/i</span>ncr-<span class="hljs-number">0.2</span>.zsh<br>mkdir ~<span class="hljs-regexp">/.oh-my-zsh/</span>plugins/incr<br>mv incr-<span class="hljs-number">0.2</span>.zsh ~<span class="hljs-regexp">/.oh-my-zsh/</span>plugins/incr<br>echo <span class="hljs-string">&#x27;source ~/.oh-my-zsh/plugins/incr/incr*.zsh&#x27;</span> &gt;&gt; ~/.zshrc<br>source ~/.zshrc<br></code></pre></td></tr></table></figure><p>可以开心的敲命令行了~</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;环境为wsl-ubuntu18&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/wklesss/picture@latest/img/image-20210907170638965.png&quot; alt=&quot;im</summary>
      
    
    
    
    <category term="工具使用" scheme="http://example.com/categories/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/"/>
    
    
    <category term="linux" scheme="http://example.com/tags/linux/"/>
    
    <category term="wsl" scheme="http://example.com/tags/wsl/"/>
    
    <category term="terminal" scheme="http://example.com/tags/terminal/"/>
    
    <category term="shell" scheme="http://example.com/tags/shell/"/>
    
    <category term="zsh" scheme="http://example.com/tags/zsh/"/>
    
    <category term="mac" scheme="http://example.com/tags/mac/"/>
    
  </entry>
  
  <entry>
    <title>Conda使用指南</title>
    <link href="http://example.com/post/3383b2ac.html"/>
    <id>http://example.com/post/3383b2ac.html</id>
    <published>2021-07-27T13:02:36.000Z</published>
    <updated>2022-06-09T07:09:39.299Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文由 <a href="http://ksria.com/simpread/">简悦 SimpRead</a> 转码， 原文地址 <a href="https://zhuanlan.zhihu.com/p/44398592">zhuanlan.zhihu.com</a></p></blockquote><p>Python 渐渐成为最流行的编程语言之一，在数据分析、机器学习和深度学习等方向 Python 语言更是主流。Python 的版本比较多，并且它的库也非常广泛，同时库和库之间存在很多依赖关系，所以在库的安装和版本的管理上很麻烦。Conda 是一个管理版本和 Python 环境的工具，它使用起来非常容易。</p><p>首先你需要安装 <a href="https://www.anaconda.com/">Anconda</a> 软件，点击链接 <a href="https://www.anaconda.com/download/">download</a>。选择对应的系统和版本类型。</p><h2 id="Conda-的环境管理"><a href="#Conda-的环境管理" class="headerlink" title="Conda 的环境管理"></a><strong>Conda 的环境管理</strong></h2><h2 id="创建环境"><a href="#创建环境" class="headerlink" title="创建环境"></a>创建环境</h2><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 创建一个名为python34的环境，指定Python版本是3.5（不用管是3.5.x，conda会为我们自动寻找3.５.x中的最新版本）</span><br>conda create --name py35 python=3.5<br><br></code></pre></td></tr></table></figure><h2 id="激活环境"><a href="#激活环境" class="headerlink" title="激活环境"></a>激活环境</h2><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 安装好后，使用activate激活某个环境</span><br>activate py35 # for Windows<br>source activate py35 # for Linux &amp; Mac<br>(py35) user@user-XPS-8920:~$<br><span class="hljs-meta"> #</span><span class="bash"> 激活后，会发现terminal输入的地方多了py35的字样，实际上，此时系统做的事情就是把默认2.7环境从PATH中去除，再把3.4对应的命令加入PATH</span><br><br>(py35) user@user-XPS-8920:~$ python --version<br>Python 3.5.5 :: Anaconda, Inc.<br><span class="hljs-meta">#</span><span class="bash"> 可以得到`Python 3.5.5 :: Anaconda, Inc.`，即系统已经切换到了3.５的环境</span><br><br></code></pre></td></tr></table></figure><h2 id="返回主环境"><a href="#返回主环境" class="headerlink" title="返回主环境"></a>返回主环境</h2><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 如果想返回默认的python 2.7环境，运行</span><br>deactivate py35 # for Windows<br>source deactivate py35 # for Linux &amp; Mac<br><br></code></pre></td></tr></table></figure><h2 id="删除环境"><a href="#删除环境" class="headerlink" title="删除环境"></a>删除环境</h2><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 删除一个已有的环境</span><br>conda remove --name py35 --all<br><br></code></pre></td></tr></table></figure><h2 id="查看系统中的所有环境"><a href="#查看系统中的所有环境" class="headerlink" title="查看系统中的所有环境"></a>查看系统中的所有环境</h2><p>用户安装的不同 Python 环境会放在<code>~/anaconda/envs</code>目录下。查看当前系统中已经安装了哪些环境，使用<code>conda info -e</code>。</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">user@user-XPS-8920:~$ conda info -e<br><span class="hljs-meta">#</span><span class="bash"> conda environments:</span><br><span class="hljs-meta">#</span><span class="bash"></span><br><span class="bash">base                  *  /home/user/anaconda2</span><br>caffe                    /home/user/anaconda2/envs/caffe<br>py35                    /home/user/anaconda2/envs/py35<br>tf                       /home/user/anaconda2/envs/tf<br><br></code></pre></td></tr></table></figure><h2 id="Conda-的包管理"><a href="#Conda-的包管理" class="headerlink" title="Conda 的包管理"></a><strong>Conda 的包管理</strong></h2><h2 id="安装库"><a href="#安装库" class="headerlink" title="安装库"></a>安装库</h2><p>为当前环境安装库</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> numpy</span><br>conda install numpy<br><span class="hljs-meta">#</span><span class="bash"> conda会从从远程搜索numpy的相关信息和依赖项目</span><br></code></pre></td></tr></table></figure><h2 id="查看已经安装的库"><a href="#查看已经安装的库" class="headerlink" title="查看已经安装的库"></a>查看已经安装的库</h2><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 查看已经安装的packages</span><br>conda list<br><span class="hljs-meta">#</span><span class="bash"> 最新版的conda是从site-packages文件夹中搜索已经安装的包，可以显示出通过各种方式安装的包</span><br></code></pre></td></tr></table></figure><h2 id="查看某个环境的已安装包"><a href="#查看某个环境的已安装包" class="headerlink" title="查看某个环境的已安装包"></a>查看某个环境的已安装包</h2><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 查看某个指定环境的已安装包</span><br>conda list -n py35<br><br></code></pre></td></tr></table></figure><h2 id="搜索-package-的信息"><a href="#搜索-package-的信息" class="headerlink" title="搜索 package 的信息"></a>搜索 package 的信息</h2><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 查找package信息</span><br>conda search numpy<br>Loading channels: done# Name                  Version           Build  Channel             numpy                     1.5.1          py26_1  pkgs/free           ...numpy                    1.15.1  py37hec00662_0  anaconda/pkgs/main  numpy                    1.15.1  py37hec00662_0  pkgs/main<br></code></pre></td></tr></table></figure><h2 id="安装-package-到指定的环境"><a href="#安装-package-到指定的环境" class="headerlink" title="安装 package 到指定的环境"></a>安装 package 到指定的环境</h2><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 安装package</span><br>conda install -n py35 numpy<br><span class="hljs-meta">#</span><span class="bash"> 如果不用-n指定环境名称，则被安装在当前活跃环境</span><br><span class="hljs-meta">#</span><span class="bash"> 也可以通过-c指定通过某个channel安装</span><br></code></pre></td></tr></table></figure><h2 id="更新-package"><a href="#更新-package" class="headerlink" title="更新 package"></a>更新 package</h2><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 更新package</span><br>conda update -n py35 numpy<br></code></pre></td></tr></table></figure><h2 id="删除-package"><a href="#删除-package" class="headerlink" title="删除 package"></a>删除 package</h2><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 删除package</span><br>conda remove -n py35 numpy<br></code></pre></td></tr></table></figure><h2 id="更新-conda"><a href="#更新-conda" class="headerlink" title="更新 conda"></a>更新 conda</h2><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 更新conda，保持conda最新</span><br>conda update conda<br></code></pre></td></tr></table></figure><h2 id="更新-anaconda"><a href="#更新-anaconda" class="headerlink" title="更新 anaconda"></a>更新 anaconda</h2><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 更新anaconda</span><br>conda update anaconda<br></code></pre></td></tr></table></figure><h3 id="更新Python"><a href="#更新Python" class="headerlink" title="更新Python"></a>更新Python</h3><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">更新 python<br>---------<br><br>conda update python<br><br>假设当前环境是 python 3.5, conda 会将 python 升级为 3.5.x 系列的当前最新版本<br>-------------------------------------------------------<br><br>**设置国内镜像**<br>----------<br><br>因为 [http://Anaconda.org](http://Anaconda.org) 的服务器在国外，所有有些库下载缓慢，可以使用清华 Anaconda 镜像源。 网站地址: [清华大学开源软件镜像站](https://mirrors.tuna.tsinghua.edu.cn/help/anaconda/)<br><br>Anaconda　<br>---------<br><br>镜像 Anaconda 安装包可以到 [https://mirrors.tuna.tsinghua.edu.cn/anaconda/archive/](https://mirrors.tuna.tsinghua.edu.cn/anaconda/archive/) 下载。 TUNA 还提供了 Anaconda 仓库的镜像，运行以下命令：<br>conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/ <br>conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main/ <br>conda config --set show_channel_urls yes<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">即可添加 Anaconda Python 免费仓库。<br><br>运行 `conda install numpy` 测试一下吧。<br><br>Miniconda　镜像<br>------------<br><br>Miniconda 是一个 Anaconda 的轻量级替代，默认只包含了 python 和 conda，但是可以通过 pip 和 conda 来安装所需要的包。<br><br>Miniconda 安装包可以到 [https://mirrors.tuna.tsinghua.edu.cn/anaconda/miniconda/](https://mirrors.tuna.tsinghua.edu.cn/anaconda/miniconda/) 下载。<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本文由 &lt;a href=&quot;http://ksria.com/simpread/&quot;&gt;简悦 SimpRead&lt;/a&gt; 转码， 原文地址 &lt;a href=&quot;https://zhuanlan.zhihu.com/p/44398592&quot;&gt;zhuanlan.z</summary>
      
    
    
    
    <category term="工具使用" scheme="http://example.com/categories/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/"/>
    
    
    <category term="anconda" scheme="http://example.com/tags/anconda/"/>
    
    <category term="python" scheme="http://example.com/tags/python/"/>
    
    <category term="linux" scheme="http://example.com/tags/linux/"/>
    
    <category term="wsl" scheme="http://example.com/tags/wsl/"/>
    
  </entry>
  
  <entry>
    <title>wsl2固定ip方案</title>
    <link href="http://example.com/post/fef49edf.html"/>
    <id>http://example.com/post/fef49edf.html</id>
    <published>2021-07-27T12:13:46.000Z</published>
    <updated>2022-06-09T07:09:39.299Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/wklesss/picture@latest/img/image-20210727201410270.png" alt="image-20210727201410270"></p><p>I give you a new idea: Instead of changing the IP, add a designated IP.</p><p>In Windows 10, run CMD or Powershell with administrator privilege, and then execute the following two commands:</p><p>:: Add an IP address in Ubuntu, 192.168.50.16, named eth0:1<br><code>wsl -d Ubuntu -u root ip addr add 192.168.50.16/24 broadcast 192.168.50.255 dev eth0 label eth0:1</code></p><p>:: Add an IP address in Win10, 192.168.50.88<br><code>netsh interface ip add address &quot;vEthernet (WSL)&quot; 192.168.50.88 255.255.255.0</code></p><p>In the future, you will use 192.168.50.16 when you access Ubuntu, and 192.168.50.88 when you access Win10.<br>You can save the above two lines of commands as a .bat file, and then put it into the boot area, and let it execute automatically every time.</p><p>windows10中，以管理员权限运行 CMD 或者Powershell。然后运行以下两条命令</p><p>分配IP给wsl：</p><p><code>wsl -d Ubuntu -u root ip addr add 192.168.50.16/24 broadcast 192.168.50.255 dev eth0 label eth0:1</code></p><p>分配IP给win10：</p><p><code>netsh interface ip add address &quot;vEthernet (WSL)&quot; 192.168.50.88 255.255.255.0</code></p><p>以后你访问Ubuntu时会使用192.168.50.16，访问Win10时会使用192.168.50.88。 可以将以上两行命令保存为.bat文件，然后放入boot区，让它每次都自动执行。</p><p>以上方案不会修改电脑原ip地址，只是将系统和wsl连入同一虚拟局域网中。</p><p><img src="https://cdn.jsdelivr.net/gh/wklesss/picture@latest/img/image-20210727202405677.png" alt="image-20210727202405677"></p><p><img src="https://cdn.jsdelivr.net/gh/wklesss/picture@latest/img/image-20210727202431291.png" alt="image-20210727202431291"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/wklesss/picture@latest/img/image-20210727201410270.png&quot; alt=&quot;image-20210727201410270&quot;&gt;&lt;/p&gt;
&lt;p&gt;I giv</summary>
      
    
    
    
    <category term="工具使用" scheme="http://example.com/categories/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/"/>
    
    
    <category term="wsl" scheme="http://example.com/tags/wsl/"/>
    
    <category term="github" scheme="http://example.com/tags/github/"/>
    
    <category term="代理" scheme="http://example.com/tags/%E4%BB%A3%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>python安装及pip配置</title>
    <link href="http://example.com/post/fc64799c.html"/>
    <id>http://example.com/post/fc64799c.html</id>
    <published>2021-07-20T13:08:13.000Z</published>
    <updated>2022-06-09T07:09:39.299Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文由 <a href="http://ksria.com/simpread/">简悦 SimpRead</a> 转码， 原文地址 <a href="http://www.cppcns.com/jiaoben/python/369691.html">www.cppcns.com</a></p></blockquote><blockquote><p>这篇文章主要介绍了 Ubuntu16 安装 Python3.9 的实现步骤，文中通过示例代码介绍的非常详细，对大家的学习或者工作具有一定的参考学习价值，需要的朋友们下面随着小编来一起学习学习吧</p></blockquote><p>这篇文章主要介绍了 Ubuntu16 安装 Python3.9 的实现步骤，文中通过示例代码介绍的非常详细，对大家的学习或者工作具有一定的参考学习价值，需要的朋友们下面随着小编来一起学习学习吧</p><p>我是使用源码编译的方式安装的，网上有的可以添加 ppa 源进行在线安装，但我试<a href="http://www.cppcns.com/" title="编程客栈">编程客栈</a>了行不通，所以还是采用源码安装</p><h3 id="1、安装编译依赖项"><a href="#1、安装编译依赖项" class="headerlink" title="1、安装编译依赖项"></a>1、安装编译依赖项</h3><figure class="highlight q"><table><tr><td class="code"><pre><code class="hljs q">sudo apt install -y wget build-essential libreadline-<span class="hljs-built_in">dev</span> libncursesw5-<span class="hljs-built_in">dev</span> libssl-<span class="hljs-built_in">dev</span> libsqlite3-<span class="hljs-built_in">dev</span> tk-<span class="hljs-built_in">dev</span> libgdbm-<span class="hljs-built_in">dev</span> libc6-<span class="hljs-built_in">dev</span> libbz2-<span class="hljs-built_in">dev</span> libffi-<span class="hljs-built_in">dev</span> zlib1g-<span class="hljs-built_in">dev</span><br><br></code></pre></td></tr></table></figure><p>有的博文说在这一步需要升级<code>pip</code>，但我认为没必要，因为安装好 <code>[python](http://www.cppcns.com/jiaoben/python/ &quot;python&quot;)</code>后里面有最新的<code>pip</code>，修改软链接即可</p><h3 id="2、下载源码包"><a href="#2、下载源码包" class="headerlink" title="2、下载源码包"></a>2、下载源码包</h3><p>下载你需要安装的包，官网下载会特别慢，我是用手机先从官网下载之后传到电脑上的，速度快很多</p><figure class="highlight maxima"><table><tr><td class="code"><pre><code class="hljs maxima">wget https://www.python.org/ftp/python/3http://www.cppcns.com<span class="hljs-number">.9</span><span class="hljs-number">.0</span>/Python-<span class="hljs-number">3.9</span><span class="hljs-number">.0b4</span>.tgz<br> <br>tar -zxvf Python-<span class="hljs-number">3.9</span><span class="hljs-number">.0b4</span>.tgz # 解压源码包<br><br></code></pre></td></tr></table></figure><h3 id="3、编译安装"><a href="#3、编译安装" class="headerlink" title="3、编译安装"></a>3、编译安装</h3><p>进入到刚才解压的包目录中</p><figure class="highlight awk"><table><tr><td class="code"><pre><code class="hljs awk"><span class="hljs-comment">#编译参数设置</span><br>.<span class="hljs-regexp">/configure --prefix=/u</span>sr<span class="hljs-regexp">/local/</span>python3<br> <br><span class="hljs-comment">#编译</span><br>make<br> <br><span class="hljs-comment">#安装</span><br>sudo make install<br><br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/wklesss/picture@latest/img/20210720211343.png"></p><p>出现这个提示表示安装成功，下面设置软链接</p><h3 id="4、设置软链接"><a href="#4、设置软链接" class="headerlink" title="4、设置软链接"></a>4、设置软链接</h3><p>执行<code>ll /usr/local/python3/bin</code>查看安装后的可执行文件，其中<code>python3</code>是指向<code>python3.9</code>的软链接，<code>pip3</code>和<code>pip3.9</code>里面的内容一样，只需要在<code>/usr/bin/</code>目录下添加这两个文件的软链接即可</p><p><img src="https://cdn.jsdelivr.net/gh/wklesss/picture@latest/img/obipjhvkr0q.jpg"></p><p>执行<code>ll /usr/bin | grep python</code>先查看之前<code>python</code>对应软链接，每个人情况都不一样，但设置方法是一样的，删除原来的软链接，然后重新指定即可  </p><p><img src="https://cdn.jsdelivr.net/gh/wklesss/picture@latest/img/f2b3j1somvq.jpg"></p><figure class="highlight awk"><table><tr><td class="code"><pre><code class="hljs awk">sudo rm python<br>sudo rm python3 <span class="hljs-comment">#并不会删除 python2.7 和 python3.5</span><br> <br>sudo ln http:<span class="hljs-regexp">//</span>www.cppcns.com-s <span class="hljs-regexp">/usr/</span>local<span class="hljs-regexp">/python3/</span>bin<span class="hljs-regexp">/python3.9 /u</span>sr<span class="hljs-regexp">/bin/</span>python3<br>sudo ln -s <span class="hljs-regexp">/usr/</span>local<span class="hljs-regexp">/python3/</span>bin<span class="hljs-regexp">/python3.9 /u</span>sr<span class="hljs-regexp">/bin/</span>python<br> <br><span class="hljs-comment">#为 pip 设置软链编程客栈接</span><br>sudo ln -s <span class="hljs-regexp">/usr/</span>local<span class="hljs-regexp">/python3/</span>bin<span class="hljs-regexp">/pip3.9 /u</span>sr<span class="hljs-regexp">/bin/</span>pip3<br>sudo ln -s <span class="hljs-regexp">/usr/</span>local<span class="hljs-regexp">/python3/</span>bin<span class="hljs-regexp">/pip3.9 /u</span>sr<span class="hljs-regexp">/bin/</span>pip<br><br></code></pre></td></tr></table></figure><p>执行<code>ll /usr/bin | grep python</code>和<code>ll /usr/bin | grep pip</code>查看设置后的软链接，设置 ok  </p><p><img src="https://cdn.jsdelivr.net/gh/wklesss/picture@latest/img/p4rh02bndfp.jpg">  </p><p><img src="https://cdn.jsdelivr.net/gh/wklesss/picture@latest/img/i1shlnlr0y3.jpg"></p><h3 id="5、pip-错误处理"><a href="#5、pip-错误处理" class="headerlink" title="5、pip 错误处理"></a>5、pip 错误处理</h3><p>安装完成以后还有个事就是在使用<code>pip</code>安装第三方库会出现问题，执行<code>pip list</code>，如下：  </p><p><img src="https://cdn.jsdelivr.net/gh/wklesss/picture@latest/img/4nobu3ajbc1.jpg">  </p><p>意思是在执行<code>lsb_release -a</code>这个命令出现问题，<code>lsb_release</code>这个文件在目录<code>/usr/bin</code>下</p><p>有的博文说删了这个文件就 ok，不删也可以，执行<code>sudo vi /usr/bin/lsb_release</code>将第一行中的<code>python3</code>改为<code>python3.5</code>，因为之前的<code>python3</code>是指向<code>python3.5</code>的，让它使用原来的解释器即可。然后再执行<code>pip list</code>，已经没有问题了</p><p><img src="https://cdn.jsdelivr.net/gh/wklesss/picture@latest/img/l3rm0vpmifm.jpg"><br><img src="https://cdn.jsdelivr.net/gh/wklesss/picture@latest/img/mvcop2qiuao.jpg"></p><h3 id="6、添加第三方库安装源"><a href="#6、添加第三方库安装源" class="headerlink" title="6、添加第三方库安装源"></a>6、添加第三方库安装源</h3><p>玩<code>python</code>需要安装很多的第三方模块，直接用<code>pip</code>下载安装会比较慢，可添加国内镜像源地址，下载的文件时一样的，但速度会快很多。配置方法：</p><p>a. 找到下列文件，如果不存在，之间创建相应目录和文件即可</p><p>b. 在上述文件中添加或修改：</p><figure class="highlight pgsql"><table><tr><td class="code"><pre><code class="hljs pgsql">[<span class="hljs-keyword">global</span>] <br><span class="hljs-keyword">index</span>-url=http://pypi.douban.com/simple/<br>[install]<br><span class="hljs-keyword">trusted</span>-host=pypi.douban.com<br><br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/wklesss/picture@latest/img/eev2ozkeneg.jpg"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本文由 &lt;a href=&quot;http://ksria.com/simpread/&quot;&gt;简悦 SimpRead&lt;/a&gt; 转码， 原文地址 &lt;a href=&quot;http://www.cppcns.com/jiaoben/python/369691.html&quot;</summary>
      
    
    
    
    <category term="工具使用" scheme="http://example.com/categories/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/"/>
    
    
    <category term="Python" scheme="http://example.com/tags/Python/"/>
    
    <category term="pip" scheme="http://example.com/tags/pip/"/>
    
    <category term="ubuntu" scheme="http://example.com/tags/ubuntu/"/>
    
  </entry>
  
  <entry>
    <title>解决wsl-remote无法连接</title>
    <link href="http://example.com/post/dc809001.html"/>
    <id>http://example.com/post/dc809001.html</id>
    <published>2021-07-20T11:48:45.000Z</published>
    <updated>2022-06-09T07:09:39.301Z</updated>
    
    <content type="html"><![CDATA[<h3 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h3><p>系统：windows10<br>linux 子系统：ubuntu18.04 LTS<br>vscode：1.42.1<br>remote-wsl：0.42.3</p><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>在连接 linux 子系统时报错：</p><figure class="highlight awk"><table><tr><td class="code"><pre><code class="hljs awk">sh: <span class="hljs-number">1</span>: <span class="hljs-regexp">/mnt/</span>c<span class="hljs-regexp">/Users/</span>li<span class="hljs-regexp">/.vscode/</span>extensions<span class="hljs-regexp">/ms-vscode-remote.remote-wsl-0.42.3/</span>scripts/wslServer.sh: Permission denied<br>VS Code Server <span class="hljs-keyword">for</span> WSL closed unexpectedly.<br><br></code></pre></td></tr></table></figure><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>打开 linux 子系统，执行下列命令切换到 scripts 目录：</p><figure class="highlight awk"><table><tr><td class="code"><pre><code class="hljs awk">cd <span class="hljs-regexp">/mnt/</span>c<span class="hljs-regexp">/Users/</span>XXX<span class="hljs-regexp">/.vscode/</span>extensions<span class="hljs-regexp">/ms-vscode-remote.remote-wsl-0.42.3/</span>scripts<br><br></code></pre></td></tr></table></figure><p>其中<code>XXX</code>为你的用户名<br>然后执行命令：</p><figure class="highlight llvm"><table><tr><td class="code"><pre><code class="hljs llvm">chmod +<span class="hljs-keyword">x</span> *<br><br></code></pre></td></tr></table></figure><p>再次连接即可成功。</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://github.com/microsoft/vscode-remote-release/issues/2126">cant connect to wsl-remote</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;环境&quot;&gt;&lt;a href=&quot;#环境&quot; class=&quot;headerlink&quot; title=&quot;环境&quot;&gt;&lt;/a&gt;环境&lt;/h3&gt;&lt;p&gt;系统：windows10&lt;br&gt;linux 子系统：ubuntu18.04 LTS&lt;br&gt;vscode：1.42.1&lt;br&gt;remote-w</summary>
      
    
    
    
    <category term="工具使用" scheme="http://example.com/categories/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/"/>
    
    
    <category term="wsl" scheme="http://example.com/tags/wsl/"/>
    
    <category term="ubuntu" scheme="http://example.com/tags/ubuntu/"/>
    
    <category term="vscode" scheme="http://example.com/tags/vscode/"/>
    
  </entry>
  
  <entry>
    <title>git基于ssh的加速方法</title>
    <link href="http://example.com/post/4684b22f.html"/>
    <id>http://example.com/post/4684b22f.html</id>
    <published>2021-07-20T11:20:14.000Z</published>
    <updated>2022-06-09T07:09:39.299Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文由 <a href="http://ksria.com/simpread/">简悦 SimpRead</a> 转码， 原文地址 <a href="https://www.cnblogs.com/StevenWind/p/11735352.html">www.cnblogs.com</a></p></blockquote><p><strong>背景：</strong></p><p>刚才在使用 github 时，发现直接下载 zip 的时候，速度非常快，但是使用 git clone 时发现速度只有 15kb/s 左右。这一定是不合理。</p><p>想着使用梯子，下载速度一定会有所提升，结果发现速度直接使用全局代理是不能有帮助。</p><p>所以花了一些时间研究了以下。</p><p><strong>预备知识：</strong></p><p>首先，git clone 有两个种，一种是基于 http 的 (暂把其代号设为 A，便于后续分类讨论)，另一种是基于 ssh 的 (暂把其代号设为 B，便于后续分类讨论)。</p><p>使用形式分别为：</p><p>　　git clone <a href="https://github.com/stevenlovegrove/Pangolin.git">https://github.com/stevenlovegrove/Pangolin.git</a></p><p>　　gti clone <a href="mailto:&#x67;&#x69;&#116;&#64;&#103;&#105;&#116;&#x68;&#x75;&#x62;&#46;&#x63;&#x6f;&#109;">&#x67;&#x69;&#116;&#64;&#103;&#105;&#116;&#x68;&#x75;&#x62;&#46;&#x63;&#x6f;&#109;</a>:stevenlovegrove/Pangolin.git　　</p><p>另外，基于 shadowsocks 的代理，也是有两种方法的，一种是 http(暂把其代号设为 1，便于后续分类讨论)，另一只是 socks5(暂把其代号设为 2，便于后续分类讨论) 的。</p><p>如下图我的协议就是 socks5 的。</p><p><img src="https://cdn.jsdelivr.net/gh/wklesss/picture@latest/img/959011-20191026153840907-1303696680.png"></p><p>好的，一切准备就绪，因为现在有两种 git 协议 (A,B)，两种代理协议 (1,2)，所以有四种设置方法。</p><p><strong>A1: 基于 http 的 git 与基于 http 的代理</strong></p><p>好的，一切准备就绪，因为现在有两种 git 协议 (A,B)，两种代理协议 (1,2)，所以有四种设置方法。</p><figure class="highlight verilog"><table><tr><td class="code"><pre><code class="hljs verilog">git <span class="hljs-keyword">config</span> --<span class="hljs-keyword">global</span> http<span class="hljs-variable">.proxy</span> <span class="hljs-string">&quot;http://127.0.0.1:1080&quot;</span><br>git <span class="hljs-keyword">config</span> --<span class="hljs-keyword">global</span> https<span class="hljs-variable">.proxy</span> <span class="hljs-string">&quot;http://127.0.0.1:1080&quot;</span><br><br><br></code></pre></td></tr></table></figure><p><strong>A2: 基于 http 的 git 与基于 socks5 的代理</strong></p><figure class="highlight verilog"><table><tr><td class="code"><pre><code class="hljs verilog">git <span class="hljs-keyword">config</span> --<span class="hljs-keyword">global</span> http<span class="hljs-variable">.proxy</span> <span class="hljs-string">&quot;socks5://127.0.0.1:1080&quot;</span><br>git <span class="hljs-keyword">config</span> --<span class="hljs-keyword">global</span> https<span class="hljs-variable">.proxy</span> <span class="hljs-string">&quot;socks5://127.0.0.1:1080&quot;</span><br><br><br><br></code></pre></td></tr></table></figure><p><strong>B1: 基于 ssh 的 git 与基于 http 的代理</strong></p><p>   修改~/.ssh/config 文件，如在 ubuntu 下使用: gedit ~/.ssh/config</p><p>　添加如下内容:</p><p>Host github.com<br>HostName github.com<br>User git<br>ProxyCommand socat - PROXY:127.0.0.1:%h:%p,proxyport=1080</p><p>　添加完毕，记得保存</p><p><strong>B2: 基于 ssh 的 git 与基于 socks5 的代理</strong></p><p>    修改~/.ssh/config 文件，如在 ubuntu 下使用: gedit ~/.ssh/config</p><p>　添加如下内容:</p><p>Host github.com<br>HostName github.com<br>User git<br>ProxyCommand nc -v -x 127.0.0.1:1080 %h %p</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本文由 &lt;a href=&quot;http://ksria.com/simpread/&quot;&gt;简悦 SimpRead&lt;/a&gt; 转码， 原文地址 &lt;a href=&quot;https://www.cnblogs.com/StevenWind/p/11735352.htm</summary>
      
    
    
    
    <category term="工具使用" scheme="http://example.com/categories/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/"/>
    
    
    <category term="github" scheme="http://example.com/tags/github/"/>
    
    <category term="ssh" scheme="http://example.com/tags/ssh/"/>
    
    <category term="proxy" scheme="http://example.com/tags/proxy/"/>
    
  </entry>
  
  <entry>
    <title>代理设置</title>
    <link href="http://example.com/post/90972878.html"/>
    <id>http://example.com/post/90972878.html</id>
    <published>2021-07-20T10:35:39.000Z</published>
    <updated>2022-06-09T07:09:39.300Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文由 <a href="http://ksria.com/simpread/">简悦 SimpRead</a> 转码， 原文地址 <a href="https://cuizhe.me/201905/534.cz">cuizhe.me</a></p></blockquote><h3 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h3><p>可在用户根目录<code>cd ~</code>下配置,<code>.zshrc</code> 或者 <code>.bashrc</code>根据使用的终端自行选择.</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">export https_proxy=https://localhost:port<br>export http_proxy=http://localhost:port<br>export all_proxy=socks5://localhost:port<br></code></pre></td></tr></table></figure><h3 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h3><p>可在用户根目录<code>cd ~</code>下配置,<code>.zshrc</code><br>可使用<code>proxy</code>&amp;<code>noproxy</code> 开启 &amp; 关闭</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> <span class="hljs-built_in">where</span> proxy</span><br>proxy () &#123;<br>  export all_proxy=socks5://localhost:port<br>  echo &quot;HTTP Proxy on&quot;<br>&#125;<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash"> <span class="hljs-built_in">where</span> noproxy</span><br>noproxy () &#123;<br>  unset all_proxy<br>  echo &quot;HTTP Proxy off&quot;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h4><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">curl cip.cc<br></code></pre></td></tr></table></figure><h3 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h3><h5 id="方法一图"><a href="#方法一图" class="headerlink" title="方法一图"></a>方法一图</h5><p><img src="https://cdn.jsdelivr.net/gh/wklesss/picture@latest/img/700765542.png"></p><p><code>注:</code>更新后如果不使用可以加<code>#</code>注释掉的, 方便以后使用.</p><h5 id="方法二图"><a href="#方法二图" class="headerlink" title="方法二图"></a>方法二图</h5><p><img src="https://cdn.jsdelivr.net/gh/wklesss/picture@latest/img/3455640031.png"></p><h3 id="zsh-更新"><a href="#zsh-更新" class="headerlink" title="zsh 更新"></a>zsh 更新</h3><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">upgrade_oh_my_zsh<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/wklesss/picture@latest/img/1756902685.png"></p><h3 id="官方手册"><a href="#官方手册" class="headerlink" title="官方手册"></a>官方手册</h3><h3 id="方法三：（推荐）"><a href="#方法三：（推荐）" class="headerlink" title="方法三：（推荐）"></a>方法三：（推荐）</h3><h3 id="zsh-proxy-传送阵"><a href="#zsh-proxy-传送阵" class="headerlink" title="zsh-proxy - 传送阵"></a>zsh-proxy - <a href="https://github.com/SukkaW/zsh-proxy">传送阵</a></h3><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><h3 id="oh-my-zsh"><a href="#oh-my-zsh" class="headerlink" title="oh-my-zsh"></a>oh-my-zsh</h3><p>Firstly, clone this repository in <code>oh-my-zsh</code>‘s plugins directory.</p><figure class="highlight awk"><table><tr><td class="code"><pre><code class="hljs awk">git clone https:<span class="hljs-regexp">//gi</span>thub.com<span class="hljs-regexp">/sukkaw/</span>zsh-proxy.git ~<span class="hljs-regexp">/.oh-my-zsh/</span>custom<span class="hljs-regexp">/plugins/</span>zsh-proxy<br></code></pre></td></tr></table></figure><p>Secondly, activate the plugin in <code>~/.zshrc</code>. Enable it by adding <code>zsh-proxy</code> to the <a href="https://github.com/robbyrussell/oh-my-zsh/blob/master/templates/zshrc.zsh-template#L66">plugins array</a>.</p><figure class="highlight abnf"><table><tr><td class="code"><pre><code class="hljs abnf"><span class="hljs-attribute">plugins</span>=(<br>    [plugins<br>     ...]<br>    zsh-proxy<br>)<br></code></pre></td></tr></table></figure><h3 id="Antigen"><a href="#Antigen" class="headerlink" title="Antigen"></a>Antigen</h3><p><a href="https://github.com/zsh-users/antigen">Antigen</a> is a zsh plugin manager, and it support <code>oh-my-zsh</code> plugin as well. You only need to add <code>antigen bundle sukkaw/zsh-proxy</code> to your <code>.zshrc</code> with your other bundle commands if you are using Antigen. Antigen will handle cloning the plugin for you automatically the next time you start zsh. You can also add the plugin to a running zsh with <code>antigen bundle sukkaw/zsh-proxy</code> for testing before adding it to your <code>.zshrc</code>.</p><hr><p>Congratulations! Open a new terminal or run <code>source $HOME/.zshrc</code>. If you see following lines, you have successfully installed <code>zsh-proxy</code>:</p><figure class="highlight asciidoc"><table><tr><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-code">----------------------------------------</span><br><span class="hljs-code">You should run following command first:</span><br><span class="hljs-code">$ init_proxy</span><br><span class="hljs-code">----------------------------------------</span><br></code></pre></td></tr></table></figure><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><h3 id="init-proxy"><a href="#init-proxy" class="headerlink" title="init_proxy"></a><code>init_proxy</code></h3><p>The tip mentioned below will show up next time you open a new terminal if you haven’t initialized the plugin with <code>init_proxy</code>.</p><p>After you run <code>init_proxy</code>, it is time to configure the plugin.</p><h3 id="config-proxy"><a href="#config-proxy" class="headerlink" title="config_proxy"></a><code>config_proxy</code></h3><p>Execute <code>config_proxy</code> will lead you to zsh-proxy configuration. Fill in socks5 &amp; http proxy address in format <code>address:port</code> like <code>127.0.0.1:1080</code> &amp; <code>127.0.0.1:8080</code>.</p><p>Default configuration of socks5 proxy is <code>127.0.0.1:1080</code>, and http proxy is <code>127.0.0.1:8080</code>. You can leave any of them blank during configuration to use their default configuration.</p><p>Currently <code>zsh-proxy</code> doesn’t support proxy with authentication, but I am working on it.</p><h3 id="proxy"><a href="#proxy" class="headerlink" title="proxy"></a><code>proxy</code></h3><p>After you configure the <code>zsh-proxy</code>, you are good to go. Try following command will enable proxy for supported package manager &amp; software:</p><figure class="highlight elixir"><table><tr><td class="code"><pre><code class="hljs elixir"><span class="hljs-variable">$ </span>proxy<br></code></pre></td></tr></table></figure><p>And next time you open a new terminal, zsh-proxy will automatically enable proxy for you.</p><h3 id="noproxy"><a href="#noproxy" class="headerlink" title="noproxy"></a><code>noproxy</code></h3><p>If you want to disable proxy, you can run following command:</p><figure class="highlight elixir"><table><tr><td class="code"><pre><code class="hljs elixir"><span class="hljs-variable">$ </span>noproxy<br></code></pre></td></tr></table></figure><h3 id="myip"><a href="#myip" class="headerlink" title="myip"></a><code>myip</code></h3><p>If you forget whether you have enabled proxy or not, it is fine to run <code>proxy</code> command directly, as <code>proxy</code> will reset all the proxy before enable them. But the smarter way is to use following command to check which IP you are using now:</p><figure class="highlight elixir"><table><tr><td class="code"><pre><code class="hljs elixir"><span class="hljs-variable">$ </span>myip<br></code></pre></td></tr></table></figure><p>Check procedure will use <code>curl</code> and the IP data come from <code>ipip.net</code>, <code>ip.cn</code> &amp; <code>ip.gs</code>.</p><h2 id="Uninstallation"><a href="#Uninstallation" class="headerlink" title="Uninstallation"></a>Uninstallation</h2><p><strong>If you install <code>zsh-proxy</code> with Antigen</strong>, you need to remove <code>antigen bundle sukkaw/zsh-proxy</code> to disable the plugin. <strong>If you install <code>zsh-proxy</code> with oh-myzsh</strong>, you need to remove <code>zsh-proxy</code> item from plugin array, then run <code>rm -rf ~/.oh-my-zsh/custom/plugins/zsh-proxy</code> to remove the plugin.</p><p>And you can clean up files &amp; folders created by <code>zsh-proxy</code> using following command:</p><figure class="highlight powershell"><table><tr><td class="code"><pre><code class="hljs powershell"><span class="hljs-variable">$</span> <span class="hljs-built_in">rm</span> <span class="hljs-literal">-rf</span> ~/.zsh<span class="hljs-literal">-proxy</span><br></code></pre></td></tr></table></figure><h2 id="Supported"><a href="#Supported" class="headerlink" title="Supported"></a>Supported</h2><p><code>zsh-proxy</code> currently support those package manager &amp; software:</p><ul><li><code>http_proxy</code></li><li><code>https_proxy</code></li><li><code>ftp_proxy</code></li><li><code>rsync_proxy</code></li><li><code>all_proxy</code></li><li>git (http)</li><li>npm &amp; yarn</li><li>apt</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本文由 &lt;a href=&quot;http://ksria.com/simpread/&quot;&gt;简悦 SimpRead&lt;/a&gt; 转码， 原文地址 &lt;a href=&quot;https://cuizhe.me/201905/534.cz&quot;&gt;cuizhe.me&lt;/a&gt;&lt;/p</summary>
      
    
    
    
    <category term="工具使用" scheme="http://example.com/categories/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/"/>
    
    
    <category term="linux" scheme="http://example.com/tags/linux/"/>
    
    <category term="proxy" scheme="http://example.com/tags/proxy/"/>
    
    <category term="zsh" scheme="http://example.com/tags/zsh/"/>
    
  </entry>
  
  <entry>
    <title>高效书签管理</title>
    <link href="http://example.com/post/b76c446d.html"/>
    <id>http://example.com/post/b76c446d.html</id>
    <published>2021-07-09T02:18:50.000Z</published>
    <updated>2022-06-09T07:09:39.301Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文由 <a href="http://ksria.com/simpread/">简悦 SimpRead</a> 转码， 原文地址 <a href="https://www.runningcheese.com/bm">www.runningcheese.com</a></p></blockquote><blockquote><p>导读</p></blockquote><h2 id="导读"><a href="#导读" class="headerlink" title="导读"></a>导读</h2><p><img src="https://cdn.jsdelivr.net/gh/wklesss/picture@latest/img/20210709102937.jpeg"></p><p>当你在群里问 “ <strong>有没有 XXX 的网站</strong> “ 时，如果有人立马甩给你一个链接，那多半是因为他的书签里有这个网站。</p><p>书签，是一种用来储存网页链接的设计，是我们上网的导航，只需要轻轻点击，就能前往互联网的深处。书签收藏数量的多少，可以体现我们对互联网的认知水平，多年来，浏览器我们可能换过不少，但书签会一直保持更新，书签算得上是我们浏览器上最重要的资产。</p><p>那这份 “资产” 要如何管理呢？本期内容就来看看奶酪是如何管理超过 5000 多个书签的。</p><h2 id="一、书签的筛选"><a href="#一、书签的筛选" class="headerlink" title="一、书签的筛选"></a>一、书签的筛选</h2><p>在面对「XXX 管理」的问题时，很多人总会第一时间想到有没有什么工具可以帮助管理，以为找到合适的工具就万事大吉了，殊不知，工具从来都不是管理的根本，思路才是。</p><p>首先，我们要明确的什么样的网页值得加入书签，什么样的不值得。</p><p>我们可以根据网页的「<strong>使用频率</strong>」还有「<strong>时效价值</strong>」来作判断，只有那些经常需要访问的，又或者有长期价值的网页才值得加入书签，如果能做到这一步，书签管理可以说就完成了一半了。</p><p><a href="https://tvax1.sinaimg.cn/large/7a6a15d5gy1gjwoc185pvj20zk0k0mzo.jpg"><img src="https://cdn.jsdelivr.net/gh/wklesss/picture@latest/img/20210709102942.jpeg"></a></p><p><strong>1、经常使用、长期有用。</strong></p><p>经常使用和长期有用的书签，通常会是网站的主页又或者是某个专题页面，而不会是某个具体页面。只收集这样的书签，一是数量可控，二是不容易出现书签失效的情况，这样一来，我们的书签管理压力就大大减少了。</p><p><strong>2、经常使用、短期有用。</strong></p><p>那短期内才需要经常使用的书签要怎么处理呢？</p><p>比如我们看到一个感兴趣的网页，但暂时没时间看，打算标记一下以后再看，通常的做法是点击地址栏里 “<strong>星星</strong>” 图标，又或者使用快捷键是「<strong>Ctrl+D</strong>」将网页收藏起来，这时书签就会默认保存到一个叫做【<strong>其他书签</strong>】的文件夹里，起到「<strong>稍后阅读</strong>」的效果。</p><p>但我们有更好的解决方法，使用拓展 Pocket（支持 <a href="https://www.runningcheese.com/go?url=https://addons.mozilla.org/zh-CN/firefox/addon/in-my-pocket/?src=search">Firefox</a> / <a href="https://www.runningcheese.com/go?url=https://chrome.google.com/webstore/detail/save-to-pocket/niloccemoadcdkdjlinkgdfekeahmflj">Chrome</a> ）不但可以集中管理这类临时网页，避免了书签的臃肿，而且它还支持在多平台上使用，管理起来更加方便。</p><p><a href="https://tva1.sinaimg.cn/large/7a6a15d5gy1gjxzo066suj21yw13wk19.jpg"><img src="https://cdn.jsdelivr.net/gh/wklesss/picture@latest/img/20210709102949.jpeg"></a></p><p>那如果需要同时保存多个临时网页呢？</p><p>比如我们在做一个项目，打开了一些网页，由于上下班等原因需要暂时停止，这时我们就需要把当前打开的网页保存起来。通常的做法是使用快捷键「<strong>Ctrl+Shift+D</strong>」，当前网页就会以文件夹的形式，批量保存到【<strong>其他书签</strong>】里去，起到了「<strong>会话保存</strong>」的效果。</p><p>同样，使用拓展 <strong>Tab Session Manager</strong>（支持 <a href="https://www.runningcheese.com/go?url=https://addons.mozilla.org/zh-CN/firefox/addon/tab-session-manager/?src=search">Firefox</a> / <a href="https://www.runningcheese.com/go?url=https://chrome.google.com/webstore/detail/tab-session-manager/iaiomicjabeggjcfkbimgmglanimpnae">Chrome</a>）会是更好的选择，相比之下，它不但操作简单，而且能够自动保存，可以预防一些意外的情况。</p><p><a href="https://tvax2.sinaimg.cn/large/7a6a15d5gy1gjxfbfgq13j21yw13wn7y.jpg"><img src="https://cdn.jsdelivr.net/gh/wklesss/picture@latest/img/20210709102958.jpeg"></a></p><p><strong>3、不经常使用、长期有用。</strong></p><p>那如果一个项目短期内无法完成，需要我们持续地去收集相关的内容，又该怎么处理呢？</p><p>比如 “知识管理” 是一个需要长期关注的课题，我们会在网上看得各种各样的观点，那么我们可以创建一个专门的书签文件夹，一旦遇到相关的网页就集中放到这里来。</p><p>但这是一个笼统的做法，使用笔记的方法来收集会更加的全面，这里有很多值得说道的地方，我们在下期《文档管理》中再作深入讨论。</p><p><a href="https://tva1.sinaimg.cn/large/7a6a15d5gy1gk1gvicjonj21ry12an6p.jpg"><img src="https://tva1.sinaimg.cn/large/7a6a15d5gy1gk1gvicjonj21ry12an6p.jpg"></a></p><p><strong>4、不经常使用、短期有用。</strong></p><p>至于不经常使用，而且只有短期内才有用的网页，在历史浏览记录里查找就足够了。</p><h2 id="二、书签的分类"><a href="#二、书签的分类" class="headerlink" title="二、书签的分类"></a>二、书签的分类</h2><p>其次，我们还需要对书签进行分类，目的是为了让书签形成体系，这也是书签管理最关键的一步。</p><p><strong>1、杜威十进制分类法。</strong></p><p>在进行书签分类时，很多人都会按自己的行业，还有感兴趣的领域进行分类，然后在后续的使用中去迭代升级分类方法，那有没有一步到位的书签分类方法呢？</p><p>此前我们在《文件管理》和《电子书管理》中都使用了「<strong>杜威十进制分类法</strong>」，它能够同时兼顾知识的广度和深度，而且不管是年轻时还是年老时都能使用，可以说是一套终极的分类方法。<br><a href="https://tvax4.sinaimg.cn/large/7a6a15d5gy1gk1jea8xkoj20zk0k0jyt.jpg"><img src="https://cdn.jsdelivr.net/gh/wklesss/picture@latest/img/20210709103006.jpeg"></a></p><p><strong>杜威十进制分类法</strong>将知识分成了 10 大学科，包括 000 总类、100 哲学与心理学、200 宗教、300 社会科学、400 语言、500 自然科学、600 应用科学、700 艺术与休闲、800 文学、900 历史与地理。</p><p><a href="https://tva4.sinaimg.cn/large/7a6a15d5gy1gk1jelok2pj20zk0k0tgy.jpg"><img src="https://cdn.jsdelivr.net/gh/wklesss/picture@latest/img/20210709103014.jpeg"></a></p><p>作为知识管理中的一环，在书签的分类上，我们也应该使用同样的分类方法。</p><p>使用相同的标准，可以极大地减少我们的认知成本，就像苹果公司推出 Big Sur 操作系统，还有 ARM 架构 CPU，都是试图使用同一套标准来打通所有平台。</p><p>我们可以把书签的分类，按照《文件管理》中的那样分为「学科分类 + 工作 + 生活」，由于工作类书签的使用频率会更高，我们可以将它放它在最前面，也就变成了「工作 + 学科分类 + 生活」。</p><p><a href="https://tva1.sinaimg.cn/large/7a6a15d5gy1gjy57gzkapj21ws0f8q47.jpg"><img src="https://cdn.jsdelivr.net/gh/wklesss/picture@latest/img/20210709103021.jpeg"></a></p><p>但实际情况不会这么简单，我们还需要进行一些调整。</p><p>比如学科分类中「200 宗教」的书签会比较少，我们将它并入「100 哲学与心理学」中去。同理，如果「900 历史与地理」的书签也较少，那么就将它并入「300 社会科学」。</p><p>而如果某个学科分类的书签很多，比如我在「600 应用科学」中的「软件开发」和「平面设计」就有很多的书签，那么我们可以将它们提升一级，并列地放在根目录下。</p><p>还有一些经常要用的书签，比如 “小书签、资源搜索、在线工具” 等内容，把它们放到各个学科中会不太合适，那我们就把它们放到「000 总类」中去，所以我的书签分类最后就变成了这样。</p><p><a href="https://tva2.sinaimg.cn/large/7a6a15d5gy1gjy54d6f76j22ho0kv0v2.jpg"><img src="https://cdn.jsdelivr.net/gh/wklesss/picture@latest/img/20210709103027.jpeg"></a></p><p><strong>2、MECE 原则。</strong></p><p>使用杜威十进制分类法的另一个好处，是它分类清晰明了，可以避免分类混乱的问题。</p><p>在对事物进行分类时，往往都会用到「<strong>MECE 原则</strong>」，也就是要做到 “<strong>既无重复，也无遗漏</strong>”。为什么如此重要呢？如果分类没有涵盖问题的所有方面，那么最终推演出来的方案就有可能以偏概全，而如果分类有很多的重叠，那么我们也无法厘清事物的样貌，而杜威十进制分类法这两点都完全符合。</p><p><a href="https://tva4.sinaimg.cn/large/7a6a15d5gy1gjwqt6zrhrj20zk0k0di0.jpg"><img src="https://cdn.jsdelivr.net/gh/wklesss/picture@latest/img/20210709103031.jpeg"></a></p><p>那二级分类要如何进行细分呢？此前我们在《文件管理》中也有谈到过，我们可以大致参考这样的分类，如图：</p><p><a href="https://tva2.sinaimg.cn/large/7a6a15d5gy1gk1jf08ea0j20zk0k042k.jpg"><img src="https://cdn.jsdelivr.net/gh/wklesss/picture@latest/img/20210709103038.jpeg"></a></p><p>但有一些分类，需要我们细说一下。</p><p>比如你用书签的方法关注了 B 站上的一些 UP 主，因为这是更快的访问方法，又或者你想偷偷地关注这些 UP 主。此时你是新建一个「视频博主」的文件夹呢？还是到十大学科分类中新建一个「物理学博主」的文件夹呢？显示后者更符合 MECE 原则。</p><p>同理，当你想创建一个「博客论坛」文件夹的时候，想想如何将这些博客、论坛的书签分别放到 10 大学科的文件夹里，因为这样更能够避免分类的混乱。</p><p><a href="https://tvax1.sinaimg.cn/large/7a6a15d5gy1gk0gpj3zouj22p91iq45w.jpg"><img src="https://cdn.jsdelivr.net/gh/wklesss/picture@latest/img/20210709103043.jpeg"></a></p><p>如果有些书签你实在不知道怎么分类，那么可以设置一个暂存文件，比如下图中的 “相关素材”，把那些暂时不知道怎么分类的书签放到这里来，等以后明确了再重新分类也不迟。</p><p><a href="https://tvax4.sinaimg.cn/large/7a6a15d5gy1gjwr9jney5j20zk0k0426.jpg"><img src="https://cdn.jsdelivr.net/gh/wklesss/picture@latest/img/20210709103051.jpeg"></a></p><p><strong>3、文件夹层次不要超过 3 层。</strong></p><p>还有，书签的文件夹层次最好不要超过 3 层。当你想要的书签需要在一层一层的文件夹中去查找时，你就会觉得这是一件麻烦的事，心里也就会抗拒去做这件事，最后导致书签的使用率下降。</p><p>如果某个文件夹下的书签实在太多了，那我们可以多分几个文件夹，相同名称的文件夹可以用上标数字来区分。因为大多数浏览器都没有书签并排显示功能，书签多了就会折叠起来，只能通过滚动来查看所有书签，这无疑会提高书签查找的难度。</p><p><a href="https://tvax3.sinaimg.cn/large/7a6a15d5gy1gjz826f00wj22fs1e4qd0.jpg"><img src="https://cdn.jsdelivr.net/gh/wklesss/picture@latest/img/20210709103057.jpeg"></a></p><h2 id="三、书签的命名"><a href="#三、书签的命名" class="headerlink" title="三、书签的命名"></a>三、书签的命名</h2><p>此外，书签的命名也很重要，好的命名方法，不但能有利于查找，还能带来视觉上的美感体验。</p><p><strong>1、书签的命名规范。</strong></p><p>在添加书签时，名称默认会是「<strong>网站名称 - 标语口号</strong>」这样的格式，比如爱奇艺的书签名称会显示为「爱奇艺 - 全球领先的在线视频网站…」，太多的无用内容会造成信息干扰，我们有必要对其进行简化。</p><p>如果是知名网站，比如爱奇艺，那很好办，只需要只保留「<strong>网站名称</strong>」就可以了。而如果是不那么知名的网站，那就需要一定的技巧了，因为我们通常能记得网站的功能作用，却很难记得住它们的名字，我们可以用「<strong>网站描述 | 网站名称</strong> 」的格式来命名。</p><p>网站描述，就是你认为网站是做什么的，尽量要简单一些，而分割线 “|” 的使用则是为了让书签名称更加清晰，在有的情况下，我们甚至还可以只写「<strong>网站描述</strong>」。</p><p><a href="https://tvax1.sinaimg.cn/large/7a6a15d5gy1gjyytn05fjj22ho1egk09.jpg"><img src="https://cdn.jsdelivr.net/gh/wklesss/picture@latest/img/20210709103106.jpeg"></a></p><p><strong>2、善用分割线。</strong></p><p>当收集的书签变多时，书签堆积在一起就会变得难以分辩，使用分割线是个聪明的做法。</p><p>分割线的使用方法，其实就像是把 11 位的手机号码划分为三段 138-1234-5678，以” 块 “为单位进行信息读取，查找书签时也就更加轻松了。</p><p>水平分割线很好办，只需要在名称的后面加上 “丨” 即可，而垂直分割线，我们可以借用网站 <a href="https://www.runningcheese.com/go?url=https://separator.mayastudios.com/index.php?t=horz">Bookmarks Separator</a> 提供的 “伪分割线” 来解决，支持在分割线上添加文字，也给了我们更多的自定义空间。</p><p><a href="https://tva2.sinaimg.cn/large/7a6a15d5gy1gk0h6fgicxj22ho1egag8.jpg"><img src="https://cdn.jsdelivr.net/gh/wklesss/picture@latest/img/20210709103114.jpeg"></a></p><p><strong>3、标注书签的特点。</strong></p><p>在一批相同的书签里，如果某个书签不太一样，那我们可以做下标记，这样做的目的是为了在相同之间突出不同。</p><p>比如同类中最喜欢的那个书签可以加上 ♥，书签类型如果是 “小书签” 的就加上 ✦，某些网页如果无法正常访问（除去那些知名的网站）那就用 ▲ 来标记，而如果某些网站需要登陆才能使用，我会在后面加上（需登陆）。</p><h2 id="四、书签的调用"><a href="#四、书签的调用" class="headerlink" title="四、书签的调用"></a>四、书签的调用</h2><p>最后，书签的调用也值得细说一番，如果只是收藏起来而不用的话，那也没有发挥书签的作用。</p><p><strong>1、文件夹选取</strong></p><p>调用书签最直接的方法是在书签文件夹里选取，类似于我们在资源管理器里查找文件。</p><p>有了上面的分类和命名方法，相信书签的选取就很清晰方便了，而且，按住 Ctrl 键点击书签，书签菜单就不会关闭，这样我们就可以连续打开多个书签了。</p><p><strong>2、地址栏自动补全</strong></p><p>另一种方法是在地址栏上输入文字，然后通过地址栏的自动补全功能来调用书签，类似于我们用软件来搜索文件。</p><p>只需要输入书签的部分名称或者链接，地址栏都会自动补全完整的内容，但地址栏会优先匹配历史浏览记录，可能导致我们想要的书签无法优先显示，这里有两个方法：</p><p>一是选中这条不要的历史记录，按「Shift+Delete」键将它从地址栏里删除；二是在输入的文字后面空一格，然后加上符号 “*”，那么地址栏就会只匹配书签内容了。（Chrome 需要安装拓展 <a href="https://www.runningcheese.com/go?url=https://chrome.google.com/webstore/detail/holmes/gokficnebmomagijbakglkcmhdbchbhn">Holmes</a>）</p><p>而且，当你下次输入同样的内容时，你选择过的书签就会优先排在前面，就像输入法会将高频词放在前面一样。</p><p><a href="https://tvax2.sinaimg.cn/large/7a6a15d5gy1gjzb8r9qlnj21yi0pute8.jpg"><img src="https://cdn.jsdelivr.net/gh/wklesss/picture@latest/img/20210709103122.jpeg"></a></p><p><strong>3、通过关键字调用书签</strong></p><p>Firefox 浏览器还有一种特殊的调用方法，通过关键字可以精准调用某个书签。</p><p>我们经常要用书签都可以添加上关键字，比如我要打开我的博客，设置 runningcheese.com 的书签关键字设置为 rc，那么在地址栏里输入 rc 就会第一个匹配这个书签。</p><p><a href="https://tvax4.sinaimg.cn/large/7a6a15d5gy1gk0k3ac3enj21yi0putgs.jpg"><img src="https://cdn.jsdelivr.net/gh/wklesss/picture@latest/img/20210709103131.jpeg"></a></p><p>Chrome 浏览器没有书签关键字功能，但我们可以在 “<strong>搜索引擎管理器</strong>”里添加少量关键字，比如要打开 “书签管理器” 的话，设置关键字 <strong>bbb</strong> 还有地址 chrome://bookmarks 也可以快速调用了。</p><p><a href="https://tvax3.sinaimg.cn/large/7a6a15d5gy1gjzat7xk2ij21wq0rc79r.jpg"><img src="https://cdn.jsdelivr.net/gh/wklesss/picture@latest/img/20210709103137.jpeg"></a></p><p><strong>4、通过标签调用书签</strong></p><p>关键字只能进行一对一的匹配，如果想要一对多的话，那就要用标签了。</p><p>比如我们有一些 PDF 编辑网站，给这些书签同时设置一个标签 “apdf”，在地址栏里输入 apdf 就会匹配这些书签。</p><p><a href="https://tva4.sinaimg.cn/large/7a6a15d5gy1gk0np9uz8ej21s40zyjyx.jpg"><img src="https://cdn.jsdelivr.net/gh/wklesss/picture@latest/img/20210709103143.jpeg"></a></p><p>至于为什么要加一个前缀 a，原因是这样可以将包含有 pdf 字符的历史浏览记录排除在外，虽然在 pdf 后面输入 * 也可以将历史浏览记录排除在外，但输入这个符号会比较的麻烦。</p><p><a href="https://tvax1.sinaimg.cn/large/7a6a15d5gy1gk1mccm36ij222o160q8n.jpg"><img src="https://cdn.jsdelivr.net/gh/wklesss/picture@latest/img/20210709103151.jpeg"></a></p><p><strong>5、通过编码调用书签</strong></p><p>标签还有另外一种使用方法，我们可以用数字编码来作为标签。</p><p>前面我们使用了「杜威十进制分类法」进行分类，每个分类都可以有一个相应的编号，比如我们给「物理学」文件夹下的书签都添加上 “a520” 的标签，「物理学博主」下的书签添加上 a521，a522 等标签。</p><p><a href="https://tvax3.sinaimg.cn/large/7a6a15d5gy1gk1manlvpcj21sc106k0k.jpg"><img src="https://cdn.jsdelivr.net/gh/wklesss/picture@latest/img/20210709103200.jpeg"></a></p><p>如果想要打开这类书签时，在地址栏输入 a521、a522 就会显示这些书签，然后我们从中选择一个。</p><p>同样的方法还可以用于「游戏解说」、「电影解说」、「政论节目」等等书签，这个方法真的很能拯救一些不看视频就吃不下饭的人。</p><p><a href="https://tvax2.sinaimg.cn/large/7a6a15d5gy1gk0oov4tqlj224i0yuwnp.jpg"><img src="https://cdn.jsdelivr.net/gh/wklesss/picture@latest/img/20210709103210.jpeg"></a></p><p>不用担心你记不住这些编号，如果你在文件管理、电子书管理、笔记管理等内容中都使用同样的分类方法，使用相同的编号，这些编号就不会成为什么难事，相反，这会成为条件反射，很自然的事。</p><h2 id="五、书签的维护"><a href="#五、书签的维护" class="headerlink" title="五、书签的维护"></a>五、书签的维护</h2><p>书签的收集工作不是一天就完成的，奶酪也是经过了 15 年的沉淀才有了现在的样子，那书签要如何进行维护呢？</p><p>首先，我们要在使用的浏览器中注册一个帐号，这样书签就能保存、备份和同步了。</p><p>其次，检查书签的书签有效性也重要，我们可以用工具来进行检测，Firefox 推荐 <a href="https://www.runningcheese.com/go?url=https://addons.mozilla.org/zh-CN/firefox/addon/bookmarks-organizer/?src=search">Bookmarks Organizer</a> ，Chrome 推荐 <a href="https://www.runningcheese.com/go?url=https://chrome.google.com/webstore/detail/bookmarks-clean-up/oncbjlgldmiagjophlhobkogeladjijl">Bookmarks clean up</a>。</p><p>如果换用浏览器了，我们可以在书签管理器里，将书签导出为 html 文件，然后导入到新的浏览器里。Firefox 还支持保存为 json 格式，它可以同时保存书签的关键字和标签等内容。</p><p>如果不幸你的浏览器崩溃了，书签不见了，别担心，浏览器都会有书签自动备份功能，Firefox 可以在配置文件夹下的 \bookmarkbackups 里找回，Chrome 在配置文件夹下的 Default\Bookmarks 里。</p><p>注：本文由 奔跑中的奶酪 作者：<a href="https://www.runningcheese.com/author/1">奔跑中的奶酪</a> 发表，其版权均为作者所有，如需转载，请注明作者名字以及文章来源。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本文由 &lt;a href=&quot;http://ksria.com/simpread/&quot;&gt;简悦 SimpRead&lt;/a&gt; 转码， 原文地址 &lt;a href=&quot;https://www.runningcheese.com/bm&quot;&gt;www.runningchee</summary>
      
    
    
    
    <category term="工具使用" scheme="http://example.com/categories/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/"/>
    
    
    <category term="工具" scheme="http://example.com/tags/%E5%B7%A5%E5%85%B7/"/>
    
    <category term="书签" scheme="http://example.com/tags/%E4%B9%A6%E7%AD%BE/"/>
    
    <category term="chrome" scheme="http://example.com/tags/chrome/"/>
    
  </entry>
  
  <entry>
    <title>linux安装python3.9</title>
    <link href="http://example.com/post/324e8246.html"/>
    <id>http://example.com/post/324e8246.html</id>
    <published>2021-07-02T02:56:21.000Z</published>
    <updated>2022-06-09T07:09:39.299Z</updated>
    
    <content type="html"><![CDATA[<h1 id="安装环境"><a href="#安装环境" class="headerlink" title="安装环境"></a>安装环境</h1><p><img src="https://cdn.jsdelivr.net/gh/wklesss/picture@latest/img/20210702111815.png" alt="image-20210702111815035"></p><h4 id="1-查看当前-python-版本"><a href="#1-查看当前-python-版本" class="headerlink" title="1. 查看当前 python 版本"></a>1. 查看当前 python 版本</h4><p><img src="https://cdn.jsdelivr.net/gh/wklesss/picture@latest/img/20210702110010.png" alt="image-20210702110010149"></p><p>可以看到执行 python3，默认是3.8.10</p><h4 id="2-安装依赖包"><a href="#2-安装依赖包" class="headerlink" title="2. 安装依赖包"></a>2. 安装依赖包</h4><figure class="highlight mipsasm"><table><tr><td class="code"><pre><code class="hljs mipsasm">yum <span class="hljs-keyword">install </span>zlib-devel <span class="hljs-keyword">bzip2-devel </span>openssl-devel ncurses-devel sqlite-devel readline-devel tk-devel gcc make libffi-devel<br><br></code></pre></td></tr></table></figure><h4 id="3-下载源码包"><a href="#3-下载源码包" class="headerlink" title="3. 下载源码包"></a>3. 下载源码包</h4><figure class="highlight apache"><table><tr><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">wget</span> https://www.python.org/ftp/python/<span class="hljs-number">3</span>.<span class="hljs-number">9</span>.<span class="hljs-number">5</span>/Python-<span class="hljs-number">3</span>.<span class="hljs-number">9</span>.<span class="hljs-number">5</span>.tgz<br><br></code></pre></td></tr></table></figure><p>我是下载的最新的 python3.9，如果想安装其他版本，去 <a href="https://links.jianshu.com/go?to=https://www.python.org/downloads/">python 官网下载页面</a>下载对应的版本即可。 但是这个下载链接比较慢，我是用迅雷下载到本地之后，再 scp 到服务器的。</p><h4 id="4-解压安装"><a href="#4-解压安装" class="headerlink" title="4. 解压安装"></a>4. 解压安装</h4><figure class="highlight awk"><table><tr><td class="code"><pre><code class="hljs awk"><span class="hljs-comment"># 解压压缩包</span><br>tar -zxvf Python-<span class="hljs-number">3.9</span>.<span class="hljs-number">5</span>.tgz<br><br><span class="hljs-comment"># 进入文件夹</span><br>cd Python-<span class="hljs-number">3.9</span>.<span class="hljs-number">5</span><br><br><span class="hljs-comment"># 配置安装位置</span><br>.<span class="hljs-regexp">/configure prefix=/u</span>sr<span class="hljs-regexp">/local/</span>python3<br><br><span class="hljs-comment"># 安装</span><br>make &amp;&amp; make install<br><br></code></pre></td></tr></table></figure><p>如果最后没提示出错，就代表正确安装了，在 / usr/local / 目录下就会有 python3 目录</p><h4 id="5-添加软连接"><a href="#5-添加软连接" class="headerlink" title="5. 添加软连接"></a>5. 添加软连接</h4><figure class="highlight awk"><table><tr><td class="code"><pre><code class="hljs awk"><span class="hljs-comment">#添加python3的软链接 </span><br>ln -sf <span class="hljs-regexp">/usr/</span>local<span class="hljs-regexp">/python3/</span>bin<span class="hljs-regexp">/python3.9 /u</span>sr<span class="hljs-regexp">/bin/</span>python3 <br><br><span class="hljs-comment">#添加 pip3 的软链接 </span><br>ln -sf <span class="hljs-regexp">/usr/</span>local<span class="hljs-regexp">/python3/</span>bin<span class="hljs-regexp">/pip3.9 /u</span>sr<span class="hljs-regexp">/bin/</span>pip3<br><br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/wklesss/picture@latest/img/20210702112333.png" alt="image-20210702112333874"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;安装环境&quot;&gt;&lt;a href=&quot;#安装环境&quot; class=&quot;headerlink&quot; title=&quot;安装环境&quot;&gt;&lt;/a&gt;安装环境&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/wklesss/picture@latest/i</summary>
      
    
    
    
    <category term="工具使用" scheme="http://example.com/categories/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/"/>
    
    
    <category term="python" scheme="http://example.com/tags/python/"/>
    
    <category term="linux" scheme="http://example.com/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>常用ico图床链接</title>
    <link href="http://example.com/post/99c4a43d.html"/>
    <id>http://example.com/post/99c4a43d.html</id>
    <published>2021-06-21T23:56:11.000Z</published>
    <updated>2022-06-09T07:09:39.301Z</updated>
    
    <content type="html"><![CDATA[<ul><li>Fluent Reader自定义已订阅rss图标[160x160]</li></ul><p><a href="https://cdn.jsdelivr.net/gh/wklesss/picture@latest/img/20210623150832.jpg">8分电影新成员</a></p><p><a href="https://cdn.jsdelivr.net/gh/wklesss/picture@latest/img/20210623150829.jpg">8分剧集新成员</a></p><p><a href="https://cdn.jsdelivr.net/gh/wklesss/picture@latest/img/20210623150827.jpg">HelloGithub - 知乎</a></p><p><a href="https://cdn.jsdelivr.net/gh/wklesss/picture@latest/img/20210623150825.jpg">TOP250新晋速报</a></p><p><a href="https://cdn.jsdelivr.net/gh/wklesss/picture@latest/img/20210623150824.jpg">半月谈 - 知乎</a></p><p><a href="https://cdn.jsdelivr.net/gh/wklesss/picture@latest/img/20210623150822.jpg">豆瓣读书排行榜</a></p><p><a href="https://cdn.jsdelivr.net/gh/wklesss/picture@latest/img/20210623150820.jpg">豆瓣影视排行榜</a></p><p><a href="https://cdn.jsdelivr.net/gh/wklesss/picture@latest/img/20210623150819.jpg">豆瓣最热预告片</a></p><p><a href="https://cdn.jsdelivr.net/gh/wklesss/picture@latest/img/20210623150817.jpg">读报金句摘录 - 知乎</a></p><p><a href="https://cdn.jsdelivr.net/gh/wklesss/picture@latest/img/20210623150815.jpg">iDaily 每日环球视野</a></p><p><a href="https://cdn.jsdelivr.net/gh/wklesss/picture@latest/img/20210623150813.jpg">新片情报局</a></p><p><a href="https://cdn.jsdelivr.net/gh/wklesss/picture@latest/img/20210623150811.jpg">知乎日报 - 知乎</a></p><p><a href="https://cdn.jsdelivr.net/gh/wklesss/picture@latest/img/20210623154226.jpg">华尔街见闻</a></p><p><a href="https://cdn.jsdelivr.net/gh/wklesss/picture@latest/img/20210623155142.jpg">极客公园</a></p><p><a href="https://cdn.jsdelivr.net/gh/wklesss/picture@latest/img/20210623160504.png">InfoQ</a></p><p><a href="https://cdn.jsdelivr.net/gh/wklesss/picture@latest/img/20210624142837.png">IT之家</a></p><p><a href="https://cdn.jsdelivr.net/gh/wklesss/picture@latest/img/20210624142929.png">央视新闻</a></p><ul><li>wox自定义搜索图标[200x200]</li></ul><p><a href="https://cdn.jsdelivr.net/gh/wklesss/picture@latest/img/20210623145653.png">bilibili</a></p><p><a href="https://cdn.jsdelivr.net/gh/wklesss/picture@latest/img/20210623145647.png">csdn</a></p><p><a href="https://cdn.jsdelivr.net/gh/wklesss/picture@latest/img/20210623145644.png">GitHub图标</a></p><p><a href="https://cdn.jsdelivr.net/gh/wklesss/picture@latest/img/20210623145640.png">taobao</a></p><p><a href="https://cdn.jsdelivr.net/gh/wklesss/picture@latest/img/20210623145638.png">百度</a></p><p><a href="https://cdn.jsdelivr.net/gh/wklesss/picture@latest/img/20210623145635.png">豆瓣</a></p><p><a href="https://cdn.jsdelivr.net/gh/wklesss/picture@latest/img/20210623145632.png">京东</a></p><p><a href="https://cdn.jsdelivr.net/gh/wklesss/picture@latest/img/20210623145630.png">什么值得买</a></p><p><a href="https://cdn.jsdelivr.net/gh/wklesss/picture@latest/img/20210623145625.png">淘宝 </a></p><p><a href="https://cdn.jsdelivr.net/gh/wklesss/picture@latest/img/20210623145622.png">网易云</a></p><p><a href="https://cdn.jsdelivr.net/gh/wklesss/picture@latest/img/20210623145620.png">微博</a></p><p><a href="https://cdn.jsdelivr.net/gh/wklesss/picture@latest/img/20210623145617.png">简书</a></p><p><a href="https://cdn.jsdelivr.net/gh/wklesss/picture@latest/img/20210623145615.png">知乎</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;ul&gt;
&lt;li&gt;Fluent Reader自定义已订阅rss图标[160x160]&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a href=&quot;https://cdn.jsdelivr.net/gh/wklesss/picture@latest/img/20210623150832.jpg&quot;</summary>
      
    
    
    
    <category term="工具使用" scheme="http://example.com/categories/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/"/>
    
    
    <category term="icon" scheme="http://example.com/tags/icon/"/>
    
    <category term="wox" scheme="http://example.com/tags/wox/"/>
    
    <category term="rss" scheme="http://example.com/tags/rss/"/>
    
  </entry>
  
  <entry>
    <title>Alfred、Wox自定义搜索配置</title>
    <link href="http://example.com/post/b8326acb.html"/>
    <id>http://example.com/post/b8326acb.html</id>
    <published>2021-06-18T01:57:15.000Z</published>
    <updated>2022-06-09T07:09:39.298Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文由 <a href="http://ksria.com/simpread/">简悦 SimpRead</a> 转码， 原文地址 <a href="https://www.jianshu.com/p/45b2aacd0b08">www.jianshu.com</a></p></blockquote><h3 id="Alfred："><a href="#Alfred：" class="headerlink" title="Alfred："></a>Alfred：</h3><p>百度： <a href="https://www.baidu.com/s?wd=%7Bquery%7D">https://www.baidu.com/s?wd={query}</a> </p><p>微博： <a href="https://s.weibo.com/weibo/%7Bquery%7D">https://s.weibo.com/weibo/{query}</a></p><p>豆瓣： <a href="https://www.douban.com/search?q=%7Bquery%7D">https://www.douban.com/search?q={query}</a></p><p>知乎： <a href="https://www.zhihu.com/search?q=%7Bquery%7D">https://www.zhihu.com/search?q={query}</a></p><p>CSDN： <a href="https://so.csdn.net/so/search/s.do?q=%7Bquery%7D">https://so.csdn.net/so/search/s.do?q={query}</a></p><p>简书： <a href="https://www.jianshu.com/search?q=%7Bquery%7D">https://www.jianshu.com/search?q={query}</a></p><p>淘宝： <a href="https://s.taobao.com/search?q=%7Bquery%7D">https://s.taobao.com/search?q={query}</a></p><p>京东： <a href="https://search.jd.com/Search?keyword=%7Bquery%7D&amp;enc=utf-8&amp;wq=%7Bquery%7D">https://search.jd.com/Search?keyword={query}&amp;enc=utf-8&amp;wq={query}</a></p><p>什么值得买： <a href="http://search.smzdm.com/?s=%7Bquery%7D">http://search.smzdm.com/?s={query}</a></p><p>网易云音乐： <a href="https://music.163.com/#/search/m/?s={query}">https://music.163.com/#/search/m/?s={query}</a></p><p>Bilibili： <a href="https://search.bilibili.com/all?keyword=%7Bquery%7D">https://search.bilibili.com/all?keyword={query}</a></p><p>有道： <a href="http://dict.youdao.com/search?q=%7Bquery%7D">http://dict.youdao.com/search?q={query}</a></p><h3 id="Wox："><a href="#Wox：" class="headerlink" title="Wox："></a>Wox：</h3><p>只需把上面的 <strong>{query} 改成 {q}</strong> 就可以了：</p><p>百度：<a href="https://www.baidu.com/s?wd=%7Bq%7D">https://www.baidu.com/s?wd={q}</a> </p><p>微博：<a href="https://s.weibo.com/weibo/%7Bq%7D">https://s.weibo.com/weibo/{q}</a></p><p>豆瓣：<a href="https://www.douban.com/search?q=%7Bq%7D">https://www.douban.com/search?q={q}</a></p><p>知乎：<a href="https://www.zhihu.com/search?q=%7Bq%7D">https://www.zhihu.com/search?q={q}</a></p><p>CSDN： <a href="https://so.csdn.net/so/search/s.do?q=%7Bq%7D">https://so.csdn.net/so/search/s.do?q={q}</a></p><p>简书：<a href="https://www.jianshu.com/search?q=%7Bq%7D">https://www.jianshu.com/search?q={q}</a></p><p>淘宝：<a href="https://s.taobao.com/search?q=%7Bq%7D">https://s.taobao.com/search?q={q}</a></p><p>京东：<a href="https://search.jd.com/Search?keyword=%7Bq%7D&amp;enc=utf-8&amp;wq=%7Bq%7D">https://search.jd.com/Search?keyword={q}&amp;enc=utf-8&amp;wq={q}</a></p><p>什么值得买：<a href="http://search.smzdm.com/?s=%7Bq%7D">http://search.smzdm.com/?s={q}</a></p><p>网易云音乐：<a href="https://music.163.com/#/search/m/?s={q}">https://music.163.com/#/search/m/?s={q}</a></p><p>Bilibili： <a href="https://search.bilibili.com/all?keyword=%7Bq%7D">https://search.bilibili.com/all?keyword={q}</a></p><p>有道：<a href="http://dict.youdao.com/search?q=%7Bq%7D">http://dict.youdao.com/search?q={q}</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本文由 &lt;a href=&quot;http://ksria.com/simpread/&quot;&gt;简悦 SimpRead&lt;/a&gt; 转码， 原文地址 &lt;a href=&quot;https://www.jianshu.com/p/45b2aacd0b08&quot;&gt;www.jians</summary>
      
    
    
    
    <category term="工具使用" scheme="http://example.com/categories/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/"/>
    
    
    <category term="Alfred" scheme="http://example.com/tags/Alfred/"/>
    
    <category term="Wox" scheme="http://example.com/tags/Wox/"/>
    
  </entry>
  
  <entry>
    <title>我的青铜时代-罗翔</title>
    <link href="http://example.com/post/b2351b09.html"/>
    <id>http://example.com/post/b2351b09.html</id>
    <published>2021-06-12T14:31:43.000Z</published>
    <updated>2022-06-09T07:09:39.301Z</updated>
    
    <content type="html"><![CDATA[<ul><li>罗翔——离开命运的加持，你什么都不是</li></ul><p><img src="https://cdn.jsdelivr.net/gh/wklesss/picture@latest/img/20210618091809.png" alt="我的青铜时代-罗翔"></p><ul><li><p>你总是瞧不起你自己</p></li><li><p>人应该谦虚，人应该谦卑</p></li><li><p>越是便宜的东西，越是宝贵的，像阳光、空气、父母的爱</p></li><li><p>你要演好你现在所演的剧本，因为他本来可能不属于你</p></li><li><p>我就希望孩子能做一个善良的人，能够找到什么是孤独</p></li><li><p>随心所欲不逾矩</p><ul><li>浪、漫，都水字旁，会把人淹死的</li></ul></li><li><p>真正的知识，要从书本回到现实</p></li><li><p>你最重要是要做你觉得正确的事情，最重要是你听不到内心对你的抱怨，最重要是多多年以后的你，能够看得起现在的你</p></li><li><p>因为这一切是你所不配的，所以要回馈</p></li><li><p>就是因为在黑夜中看到了微光，你就朝着微光走过去，但是有的时候你会怀疑，是不是走错了，但是所有的怀疑都是为了确信</p></li><li><p>如何过看起来好的一生</p><ul><li><p>怎么定义好</p><ul><li><p>good 好  goods商品</p></li><li><p>所以做一件事情，最重要的就是赚钱吗</p></li><li><p>什么是好医生，赚钱就是好医生？</p></li><li><p>什么是好老师，赚钱就是好老师？</p></li><li><p>。。。。。。</p></li><li><p>如此，一切职业分工就没有意义了</p></li></ul></li></ul></li><li><p>你要去寻找什么是good，你才可以去过good的一生，你才可以不随波逐流，你才内心会拥有一种笃定，你才会拒绝和别人攀比，也拒绝被别人所攀比</p></li><li><p>我们要对焦，但是你的对焦点太多，就不知道你的焦点在哪了</p></li><li><p>被遗忘是必然的。爱比克泰德所说的：对于不可控的事情，保持乐观；对于可控的事情，保持谨慎。</p></li><li><p>最痛苦，最纠结的事情是：知道和做到这个巨大鸿沟的跨越。</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;ul&gt;
&lt;li&gt;罗翔——离开命运的加持，你什么都不是&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/wklesss/picture@latest/img/20210618091809.png&quot; alt=&quot;我的青铜时代-罗</summary>
      
    
    
    
    <category term="思想" scheme="http://example.com/categories/%E6%80%9D%E6%83%B3/"/>
    
    
    <category term="访谈" scheme="http://example.com/tags/%E8%AE%BF%E8%B0%88/"/>
    
  </entry>
  
  <entry>
    <title>【study note】vim</title>
    <link href="http://example.com/post/20e858c0.html"/>
    <id>http://example.com/post/20e858c0.html</id>
    <published>2021-06-03T03:21:31.000Z</published>
    <updated>2022-06-09T07:09:39.300Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文由 <a href="http://ksria.com/simpread/">简悦 SimpRead</a> 转码， 原文地址 <a href="https://www.runoob.com/linux/linux-vim.html">www.runoob.com</a></p></blockquote><blockquote><p>Linux vi/vim 所有的 Unix Like 系统都会内建 vi 文书编辑器，其他的文书编辑器则不一定会存在。</p></blockquote><p>所有的 Unix Like 系统都会内建 vi 文书编辑器，其他的文书编辑器则不一定会存在。</p><p>但是目前我们使用比较多的是 vim 编辑器。</p><p>vim 具有程序编辑的能力，可以主动的以字体颜色辨别语法的正确性，方便程序设计。</p><p>相关文章：<a href="https://www.runoob.com/w3cnote/all-vim-cheatsheat.html">史上最全 Vim 快捷键键位图 — 入门到进阶</a></p><hr><h2 id="什么是-vim？"><a href="#什么是-vim？" class="headerlink" title="什么是 vim？"></a>什么是 vim？</h2><p>Vim 是从 vi 发展出来的一个文本编辑器。代码补完、编译及错误跳转等方便编程的功能特别丰富，在程序员中被广泛使用。</p><p>简单的来说， vi 是老式的字处理器，不过功能已经很齐全了，但是还是有可以进步的地方。 vim 则可以说是程序开发者的一项很好用的工具。</p><p>连 vim 的官方网站 (<a href="http://www.vim.org/">http://www.vim.org</a>) 自己也说 vim 是一个程序开发工具而不是文字处理软件。</p><p>vim 键盘图：</p><p><img src="https://cdn.jsdelivr.net/gh/wklesss/picture@latest/img/20210603112455.gif"></p><hr><h2 id="vi-vim-的使用"><a href="#vi-vim-的使用" class="headerlink" title="vi/vim 的使用"></a>vi/vim 的使用</h2><p>基本上 vi/vim 共分为三种模式，分别是<strong>命令模式（Command mode）</strong>，<strong>输入模式（Insert mode）</strong>和<strong>底线命令模式（Last line mode）</strong>。 这三种模式的作用分别是：</p><h3 id="命令模式："><a href="#命令模式：" class="headerlink" title="命令模式："></a>命令模式：</h3><p>用户刚刚启动 vi/vim，便进入了命令模式。</p><p>此状态下敲击键盘动作会被 Vim 识别为命令，而非输入字符。比如我们此时按下 i，并不会输入一个字符，i 被当作了一个命令。</p><p>以下是常用的几个命令：</p><ul><li>  <strong>i</strong> 切换到输入模式，以输入字符。</li><li>  <strong>x</strong> 删除当前光标所在处的字符。</li><li>  <strong>:</strong> 切换到底线命令模式，以在最底一行输入命令。</li></ul><p>若想要编辑文本：启动 Vim，进入了命令模式，按下 i，切换到输入模式。</p><p>命令模式只有一些最基本的命令，因此仍要依靠底线命令模式输入更多命令。</p><h3 id="输入模式"><a href="#输入模式" class="headerlink" title="输入模式"></a>输入模式</h3><p>在命令模式下按下 i 就进入了输入模式。</p><p>在输入模式中，可以使用以下按键：</p><ul><li>  <strong>字符按键以及 Shift 组合</strong>，输入字符</li><li>  <strong>ENTER</strong>，回车键，换行</li><li>  <strong>BACK SPACE</strong>，退格键，删除光标前一个字符</li><li>  <strong>DEL</strong>，删除键，删除光标后一个字符</li><li>  <strong>方向键</strong>，在文本中移动光标</li><li>  <strong>HOME</strong>/<strong>END</strong>，移动光标到行首 / 行尾</li><li>  <strong>Page Up</strong>/<strong>Page Down</strong>，上 / 下翻页</li><li>  <strong>Insert</strong>，切换光标为输入 / 替换模式，光标将变成竖线 / 下划线</li><li>  <strong>ESC</strong>，退出输入模式，切换到命令模式</li></ul><h3 id="底线命令模式"><a href="#底线命令模式" class="headerlink" title="底线命令模式"></a>底线命令模式</h3><p>在命令模式下按下:（英文冒号）就进入了底线命令模式。</p><p>底线命令模式可以输入单个或多个字符的命令，可用的命令非常多。</p><p>在底线命令模式中，基本的命令有（已经省略了冒号）：</p><ul><li>  q 退出程序</li><li>  w 保存文件</li></ul><p>按 ESC 键可随时退出底线命令模式。</p><p>简单的说，我们可以将这三个模式想成底下的图标来表示：</p><p><img src="https://cdn.jsdelivr.net/gh/wklesss/picture@latest/img/20210603112501.png"></p><hr><h2 id="vi-vim-使用实例"><a href="#vi-vim-使用实例" class="headerlink" title="vi/vim 使用实例"></a>vi/vim 使用实例</h2><h3 id="使用-vi-vim-进入一般模式"><a href="#使用-vi-vim-进入一般模式" class="headerlink" title="使用 vi/vim 进入一般模式"></a>使用 vi/vim 进入一般模式</h3><p>如果你想要使用 vi 来建立一个名为 runoob.txt 的文件时，你可以这样做：</p><figure class="highlight elixir"><table><tr><td class="code"><pre><code class="hljs elixir"><span class="hljs-variable">$ </span>vim runoob.txt<br></code></pre></td></tr></table></figure><p>直接输入 <strong>vi 文件名</strong> 就能够进入 vi 的一般模式了。请注意，记得 vi 后面一定要加文件名，不管该文件存在与否！</p><p><img src="https://cdn.jsdelivr.net/gh/wklesss/picture@latest/img/20210603112509.jpeg"></p><h3 id="按下-i-进入输入模式-也称为编辑模式-，开始编辑文字"><a href="#按下-i-进入输入模式-也称为编辑模式-，开始编辑文字" class="headerlink" title="按下 i 进入输入模式 (也称为编辑模式)，开始编辑文字"></a>按下 i 进入输入模式 (也称为编辑模式)，开始编辑文字</h3><p>在一般模式之中，只要按下 i, o, a 等字符就可以进入输入模式了！</p><p>在编辑模式当中，你可以发现在左下角状态栏中会出现 –INSERT- 的字样，那就是可以输入任意字符的提示。</p><p>这个时候，键盘上除了 <strong>Esc</strong> 这个按键之外，其他的按键都可以视作为一般的输入按钮了，所以你可以进行任何的编辑。</p><p><img src="https://cdn.jsdelivr.net/gh/wklesss/picture@latest/img/20210603112516.jpeg"></p><h3 id="按下-ESC-按钮回到一般模式"><a href="#按下-ESC-按钮回到一般模式" class="headerlink" title="按下 ESC 按钮回到一般模式"></a>按下 ESC 按钮回到一般模式</h3><p>好了，假设我已经按照上面的样式给他编辑完毕了，那么应该要如何退出呢？是的！没错！就是给他按下 <strong>Esc</strong> 这个按钮即可！马上你就会发现画面左下角的 – INSERT – 不见了！</p><h3 id="在一般模式中按下-wq-储存后离开-vi"><a href="#在一般模式中按下-wq-储存后离开-vi" class="headerlink" title="在一般模式中按下 :wq 储存后离开 vi"></a>在一般模式中按下 <strong>:wq</strong> 储存后离开 vi</h3><p>OK，我们要存档了，存盘并离开的指令很简单，输入 <strong>:wq</strong> 即可保存离开！</p><p><img src="https://cdn.jsdelivr.net/gh/wklesss/picture@latest/img/20210603112523.jpeg"></p><p>OK! 这样我们就成功创建了一个 runoob.txt 的文件。</p><hr><h2 id="vi-vim-按键说明"><a href="#vi-vim-按键说明" class="headerlink" title="vi/vim 按键说明"></a>vi/vim 按键说明</h2><p>除了上面简易范例的 i, Esc, :wq 之外，其实 vim 还有非常多的按键可以使用。</p><h3 id="第一部分：一般模式可用的光标移动、复制粘贴、搜索替换等"><a href="#第一部分：一般模式可用的光标移动、复制粘贴、搜索替换等" class="headerlink" title="第一部分：一般模式可用的光标移动、复制粘贴、搜索替换等"></a>第一部分：一般模式可用的光标移动、复制粘贴、搜索替换等</h3><table><tbody><tr><th colspan="2">移动光标的方法</th></tr><tr><td>h 或 向左箭头键 (←)</td><td>光标向左移动一个字符</td></tr><tr><td>j 或 向下箭头键 (↓)</td><td>光标向下移动一个字符</td></tr><tr><td>k 或 向上箭头键 (↑)</td><td>光标向上移动一个字符</td></tr><tr><td>l 或 向右箭头键 (→)</td><td>光标向右移动一个字符</td></tr><tr><td colspan="2">如果你将右手放在键盘上的话，你会发现 hjkl 是排列在一起的，因此可以使用这四个按钮来移动光标。 如果想要进行多次移动的话，例如向下移动 30 行，可以使用 "30j" 或 "30↓" 的组合按键， 亦即加上想要进行的次数 (数字) 后，按下动作即可！</td></tr><tr><td>[Ctrl] + [f]</td><td>屏幕『向下』移动一页，相当于 [Page Down] 按键 (常用)</td></tr><tr><td>[Ctrl] + [b]</td><td>屏幕『向上』移动一页，相当于 [Page Up] 按键 (常用)</td></tr><tr><td>[Ctrl] + [d]</td><td>屏幕『向下』移动半页</td></tr><tr><td>[Ctrl] + [u]</td><td>屏幕『向上』移动半页</td></tr><tr><td>+</td><td>光标移动到非空格符的下一行</td></tr><tr><td>-</td><td>光标移动到非空格符的上一行</td></tr><tr><td>n&lt;space&gt;</td><td>那个 n 表示『数字』，例如 20 。按下数字后再按空格键，光标会向右移动这一行的 n 个字符。例如 20&lt;space&gt; 则光标会向后面移动 20 个字符距离。</td></tr><tr><td>0 或功能键 [Home]</td><td>这是数字『 0 』：移动到这一行的最前面字符处 (常用)</td></tr><tr><td>$ 或功能键 [End]</td><td>移动到这一行的最后面字符处 (常用)</td></tr><tr><td>H</td><td>光标移动到这个屏幕的最上方那一行的第一个字符</td></tr><tr><td>M</td><td>光标移动到这个屏幕的中央那一行的第一个字符</td></tr><tr><td>L</td><td>光标移动到这个屏幕的最下方那一行的第一个字符</td></tr><tr><td>G</td><td>移动到这个档案的最后一行 (常用)</td></tr><tr><td>nG</td><td>n 为数字。移动到这个档案的第 n 行。例如 20G 则会移动到这个档案的第 20 行 (可配合 :set nu)</td></tr><tr><td>gg</td><td>移动到这个档案的第一行，相当于 1G 啊！ (常用)</td></tr><tr><td>n&lt;Enter&gt;</td><td>n 为数字。光标向下移动 n 行 (常用)</td></tr><tr><th colspan="2">搜索替换</th></tr><tr><td>/word</td><td>向光标之下寻找一个名称为 word 的字符串。例如要在档案内搜寻 vbird 这个字符串，就输入 /vbird 即可！ (常用)</td></tr><tr><td>?word</td><td>向光标之上寻找一个字符串名称为 word 的字符串。</td></tr><tr><td>n</td><td>这个 n 是英文按键。代表重复前一个搜寻的动作。举例来说， 如果刚刚我们执行 /vbird 去向下搜寻 vbird 这个字符串，则按下 n 后，会向下继续搜寻下一个名称为 vbird 的字符串。如果是执行 ?vbird 的话，那么按下 n 则会向上继续搜寻名称为 vbird 的字符串！</td></tr><tr><td>N</td><td>这个 N 是英文按键。与 n 刚好相反，为『反向』进行前一个搜寻动作。 例如 /vbird 后，按下 N 则表示『向上』搜寻 vbird 。</td></tr><tr><td colspan="2">使用 /word 配合 n 及 N 是非常有帮助的！可以让你重复的找到一些你搜寻的关键词！</td></tr><tr><td>:n1,n2s/word1/word2/g</td><td>n1 与 n2 为数字。在第 n1 与 n2 行之间寻找 word1 这个字符串，并将该字符串取代为 word2 ！举例来说，在 100 到 200 行之间搜寻 vbird 并取代为 VBIRD 则：<br>『:100,200s/vbird/VBIRD/g』。(常用)</td></tr><tr><td>:1,$s/word1/word2/g 或 :%s/word1/word2/g</td><td>从第一行到最后一行寻找 word1 字符串，并将该字符串取代为 word2 ！(常用)</td></tr><tr><td>:1,$s/word1/word2/gc 或 :%s/word1/word2/gc</td><td>从第一行到最后一行寻找 word1 字符串，并将该字符串取代为 word2 ！且在取代前显示提示字符给用户确认 (confirm) 是否需要取代！(常用)</td></tr><tr><th colspan="2">删除、复制与贴上</th></tr><tr><td>x, X</td><td>在一行字当中，x 为向后删除一个字符 (相当于 [del] 按键)， X 为向前删除一个字符 (相当于 [backspace] 亦即是退格键) (常用)</td></tr><tr><td>nx</td><td>n 为数字，连续向后删除 n 个字符。举例来说，我要连续删除 10 个字符， 『10x』。</td></tr><tr><td>dd</td><td>删除游标所在的那一整行 (常用)</td></tr><tr><td>ndd</td><td>n 为数字。删除光标所在的向下 n 行，例如 20dd 则是删除 20 行 (常用)</td></tr><tr><td>d1G</td><td>删除光标所在到第一行的所有数据</td></tr><tr><td>dG</td><td>删除光标所在到最后一行的所有数据</td></tr><tr><td>d$</td><td>删除游标所在处，到该行的最后一个字符</td></tr><tr><td>d0</td><td>那个是数字的 0 ，删除游标所在处，到该行的最前面一个字符</td></tr><tr><td>yy</td><td>复制游标所在的那一行 (常用)</td></tr><tr><td>nyy</td><td>n 为数字。复制光标所在的向下 n 行，例如 20yy 则是复制 20 行 (常用)</td></tr><tr><td>y1G</td><td>复制游标所在行到第一行的所有数据</td></tr><tr><td>yG</td><td>复制游标所在行到最后一行的所有数据</td></tr><tr><td>y0</td><td>复制光标所在的那个字符到该行行首的所有数据</td></tr><tr><td>y$</td><td>复制光标所在的那个字符到该行行尾的所有数据</td></tr><tr><td>p, P</td><td>p 为将已复制的数据在光标下一行贴上，P 则为贴在游标上一行！ 举例来说，我目前光标在第 20 行，且已经复制了 10 行数据。则按下 p 后， 那 10 行数据会贴在原本的 20 行之后，亦即由 21 行开始贴。但如果是按下 P 呢？ 那么原本的第 20 行会被推到变成 30 行。 (常用)</td></tr><tr><td>J</td><td>将光标所在行与下一行的数据结合成同一行</td></tr><tr><td>c</td><td>重复删除多个数据，例如向下删除 10 行，[10cj]</td></tr><tr><td>u</td><td>复原前一个动作。(常用)</td></tr><tr><td>[Ctrl]+r</td><td>重做上一个动作。(常用)</td></tr><tr><td colspan="2">这个 u 与 [Ctrl]+r 是很常用的指令！一个是复原，另一个则是重做一次～ 利用这两个功能按键，你的编辑，嘿嘿！很快乐的啦！</td></tr><tr><td>.</td><td>不要怀疑！这就是小数点！意思是重复前一个动作的意思。 如果你想要重复删除、重复贴上等等动作，按下小数点『.』就好了！ (常用)</td></tr></tbody></table><h3 id="第二部分：一般模式切换到编辑模式的可用的按钮说明"><a href="#第二部分：一般模式切换到编辑模式的可用的按钮说明" class="headerlink" title="第二部分：一般模式切换到编辑模式的可用的按钮说明"></a>第二部分：一般模式切换到编辑模式的可用的按钮说明</h3><table><tbody><tr><th colspan="2">进入输入或取代的编辑模式</th></tr><tr><td>i, I</td><td>进入输入模式 (Insert mode)：<br>i 为『从目前光标所在处输入』， I 为『在目前所在行的第一个非空格符处开始输入』。 (常用)</td></tr><tr><td>a, A</td><td>进入输入模式 (Insert mode)：<br>a 为『从目前光标所在的下一个字符处开始输入』， A 为『从光标所在行的最后一个字符处开始输入』。(常用)</td></tr><tr><td>o, O</td><td>进入输入模式 (Insert mode)：<br>这是英文字母 o 的大小写。o 为在目前光标所在的下一行处输入新的一行； O 为在目前光标所在的上一行处输入新的一行！(常用)</td></tr><tr><td>r, R</td><td>进入取代模式 (Replace mode)：<br>r 只会取代光标所在的那一个字符一次；R 会一直取代光标所在的文字，直到按下 ESC 为止；(常用)</td></tr><tr><td colspan="2">上面这些按键中，在 vi 画面的左下角处会出现『--INSERT--』或『--REPLACE--』的字样。 由名称就知道该动作了吧！！特别注意的是，我们上面也提过了，你想要在档案里面输入字符时， 一定要在左下角处看到 INSERT 或 REPLACE 才能输入喔！</td></tr><tr><td>[Esc]</td><td>退出编辑模式，回到一般模式中 (常用)</td></tr></tbody></table><h3 id="第三部分：一般模式切换到指令行模式的可用的按钮说明"><a href="#第三部分：一般模式切换到指令行模式的可用的按钮说明" class="headerlink" title="第三部分：一般模式切换到指令行模式的可用的按钮说明"></a>第三部分：一般模式切换到指令行模式的可用的按钮说明</h3><table><tbody><tr><th colspan="2">指令行的储存、离开等指令</th></tr><tr><td>:w</td><td>将编辑的数据写入硬盘档案中 (常用)</td></tr><tr><td>:w!</td><td>若文件属性为『只读』时，强制写入该档案。不过，到底能不能写入， 还是跟你对该档案的档案权限有关啊！</td></tr><tr><td>:q</td><td>离开 vi (常用)</td></tr><tr><td>:q!</td><td>若曾修改过档案，又不想储存，使用 ! 为强制离开不储存档案。</td></tr><tr><td colspan="2">注意一下啊，那个惊叹号 (!) 在 vi 当中，常常具有『强制』的意思～</td></tr><tr><td>:wq</td><td>储存后离开，若为 :wq! 则为强制储存后离开 (常用)</td></tr><tr><td>ZZ</td><td>这是大写的 Z 喔！如果修改过，保存当前文件，然后退出！效果等同于 (保存并退出)</td></tr><tr><td>ZQ</td><td>不保存，强制退出。效果等同于 :q!。</td></tr><tr><td>:w [filename]</td><td>将编辑的数据储存成另一个档案（类似另存新档）</td></tr><tr><td>:r [filename]</td><td>在编辑的数据中，读入另一个档案的数据。亦即将 『filename』 这个档案内容加到游标所在行后面</td></tr><tr><td>:n1,n2 w [filename]</td><td>将 n1 到 n2 的内容储存成 filename 这个档案。</td></tr><tr><td>:! command</td><td>暂时离开 vi 到指令行模式下执行 command 的显示结果！例如<br>『:! ls /home』即可在 vi 当中察看 /home 底下以 ls 输出的档案信息！</td></tr><tr><th colspan="2">vim 环境的变更</th></tr><tr><td>:set nu</td><td>显示行号，设定之后，会在每一行的前缀显示该行的行号</td></tr><tr><td>:set nonu</td><td>与 set nu 相反，为取消行号！</td></tr></tbody></table><p>特别注意，在 vi/vim 中，数字是很有意义的！数字通常代表重复做几次的意思！ 也有可能是代表去到第几个什么什么的意思。</p><p>举例来说，要删除 50 行，则是用 『50dd』 对吧！ 数字加在动作之前，如我要向下移动 20 行呢？那就是『20j』或者是『20↓』即可。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本文由 &lt;a href=&quot;http://ksria.com/simpread/&quot;&gt;简悦 SimpRead&lt;/a&gt; 转码， 原文地址 &lt;a href=&quot;https://www.runoob.com/linux/linux-vim.html&quot;&gt;www.</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="linux" scheme="http://example.com/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>【study note】9.python类</title>
    <link href="http://example.com/post/d2f57d73.html"/>
    <id>http://example.com/post/d2f57d73.html</id>
    <published>2021-05-24T11:50:13.000Z</published>
    <updated>2022-06-09T07:09:39.300Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文由 <a href="http://ksria.com/simpread/">简悦 SimpRead</a> 转码， 原文地址 <a href="https://docs.python.org/zh-cn/3/tutorial/classes.html">docs.python.org</a></p></blockquote><blockquote><p>类把数据与功能绑定在一起。创建新类就是创建新的对象 类型，从而创建该类型的新 实例 。类实例具有多种保持自身状态的属性。类实例还支持（由类定义的）修改自身状态的方法。</p></blockquote><p>类把数据与功能绑定在一起。创建新类就是创建新的对象 _类型_，从而创建该类型的新 <em>实例</em> 。类实例具有多种保持自身状态的属性。类实例还支持（由类定义的）修改自身状态的方法。</p><p>和其他编程语言相比，Python 用非常少的新语法和语义将类加入到语言中。它是 C++ 和 Modula-3 中类机制的结合体。Python 的类提供了面向对象编程（OOP）的所有标准特性：类继承机制允许多个基类，派生类可以覆盖它基类的任何方法，一个方法可以调用基类中相同名称的的方法。对象可以包含任意数量和类型的数据。和模块一样，类也拥有 Python 天然的动态特性：在运行时创建，创建后可以修改。</p><p>在 C++ 术语中，通常类成员（包括数据成员）是 <em>public</em> (例外见下文 <a href="https://docs.python.org/zh-cn/3/tutorial/classes.html#tut-private">私有变量</a>)，所有成员函数都是 _virtual_。 与在 Modula-3 中一样，没有用于从对象的方法中引用对象成员的简写：方法函数在声明时，有一个显示的参数代表本对象，该参数由调用隐式提供。 与 Smalltalk 一样，类本身也是对象。 这为导入和重命名提供了语义。 与 C++ 和 Modula-3 不同，内置类型可以用作基类，供用户扩展。 此外，与 C++ 一样，大多数具有特殊语法（算术运算符，下标等）的内置运算符都可以为类实例而重新定义。</p><p>（由于缺乏关于类的公认术语，我会偶尔使用 Smalltalk、C++ 的术语，我还会使用 Modula-3 的术语，因为它的面向对象语义比 C++ 更接近 Python，但估计没几个读者听说过这门语言。）</p><h2 id="9-1-名称和对象-¶"><a href="#9-1-名称和对象-¶" class="headerlink" title="9.1. 名称和对象 ¶"></a>9.1. 名称和对象 <a href="https://docs.python.org/zh-cn/3/tutorial/classes.html#a-word-about-names-and-objects" title="永久链接至标题">¶</a></h2><p>对象之间相互独立，多个名称（在多个作用域内）可以绑定到同一个对象。 其他语言称之为别名。Python 初学者通常不容易理解这个概念，处理数字、字符串、元组等不可变基本类型时，可以不必理会。 但是，对涉及可变对象，如列表、字典等大多数其他类型的 Python 代码的语义，别名可能会产生意料之外的效果。这样做，通常是为了让程序受益，因为别名在某些方面就像指针。例如，传递对象的代价很小，因为实现只传递一个指针；如果函数修改了作为参数传递的对象，调用者就可以看到更改 — 无需 Pascal 用两个不同参数的传递机制。</p><h2 id="9-2-Python-作用域和命名空间-¶"><a href="#9-2-Python-作用域和命名空间-¶" class="headerlink" title="9.2. Python 作用域和命名空间 ¶"></a>9.2. Python 作用域和命名空间 <a href="https://docs.python.org/zh-cn/3/tutorial/classes.html#python-scopes-and-namespaces" title="永久链接至标题">¶</a></h2><p>在介绍类之前，我首先要告诉你一些 Python 的作用域规则。类定义对命名空间有一些巧妙的技巧，你需要知道作用域和命名空间如何工作才能完全理解正在发生的事情。顺便说一下，关于这个主题的知识对任何高级 Python 程序员都很有用。</p><p>让我们从一些定义开始。</p><p><em>namespace</em> （命名空间）是一个从名字到对象的映射。 当前大部分命名空间都由 Python 字典实现，但一般情况下基本不会去关注它们（除了要面对性能问题时），而且也有可能在将来更改。 下面是几个命名空间的例子：存放内置函数的集合（包含 <a href="https://docs.python.org/zh-cn/3/library/functions.html#abs" title="abs"><code>abs()</code></a> 这样的函数，和内建的异常等）；模块中的全局名称；函数调用中的局部名称。 从某种意义上说，对象的属性集合也是一种命名空间的形式。 关于命名空间的重要一点是，不同命名空间中的名称之间绝对没有关系；例如，两个不同的模块都可以定义一个 <code>maximize</code> 函数而不会产生混淆 — 模块的用户必须在其前面加上模块名称。</p><p>顺便说明一下，我把任何跟在一个点号之后的名称都称为 <em>属性</em> — 例如，在表达式 <code>z.real</code> 中，<code>real</code> 是对象 <code>z</code> 的一个属性。按严格的说法，对模块中名称的引用属于属性引用：在表达式 <code>modname.funcname</code> 中，<code>modname</code> 是一个模块对象而 <code>funcname</code> 是它的一个属性。在此情况下在模块的属性和模块中定义的全局名称之间正好存在一个直观的映射：它们共享相同的命名空间！ <a href="https://docs.python.org/zh-cn/3/tutorial/classes.html#id2">1</a></p><p>属性可以是只读或者可写的。如果为后者，那么对属性的赋值是可行的。模块属性是可写的，你可以写 <code>modname.the_answer = 42</code> 。可写的属性同样可以用 <a href="https://docs.python.org/zh-cn/3/reference/simple_stmts.html#del"><code>del</code></a> 语句删除。例如， <code>del modname.the_answer</code> 将会从名为 <code>modname</code> 的对象中移除 <code>the_answer</code> 属性。</p><p>命名空间在不同时刻被创建，拥有不同的生存期。包含内置名称的命名空间是在 Python 解释器启动时创建的，永远不会被删除。模块的全局命名空间在模块定义被读入时创建；通常，模块命名空间也会持续到解释器退出。被解释器的顶层调用执行的语句，从一个脚本文件读取或交互式地读取，被认为是 <a href="https://docs.python.org/zh-cn/3/library/__main__.html#module-__main__" title="__main__: The environment where the top-level script is run."><code>__main__</code></a> 模块调用的一部分，因此它们拥有自己的全局命名空间。（内置名称实际上也存在于一个模块中；这个模块被称作 <a href="https://docs.python.org/zh-cn/3/library/builtins.html#module-builtins" title="builtins: The module that provides the built-in namespace."><code>builtins</code></a> 。）</p><p>一个函数的本地命名空间在这个函数被调用时创建，并在函数返回或抛出一个不在函数内部处理的错误时被删除。（事实上，比起描述到底发生了什么，忘掉它更好。）当然，每次递归调用都会有它自己的本地命名空间。</p><p>一个 <em>作用域</em> 是一个命名空间可直接访问的 Python 程序的文本区域。 这里的 “可直接访问” 意味着对名称的非限定引用会尝试在命名空间中查找名称。</p><p>虽然作用域是静态地确定的，但它们会被动态地使用。 在执行期间的任何时刻，会有 3 或 4 个命名空间可被直接访问的嵌套作用域:</p><ul><li><p>  最先搜索的最内部作用域包含局部名称</p></li><li><p>  从最近的封闭作用域开始搜索的任何封闭函数的作用域包含非局部名称，也包括非全局名称</p></li><li><p>  倒数第二个作用域包含当前模块的全局名称</p></li><li><p>  最外面的作用域（最后搜索）是包含内置名称的命名空间</p></li></ul><p>如果一个名称被声明为全局变量，则所有引用和赋值将直接指向包含该模块的全局名称的中间作用域。 要重新绑定在最内层作用域以外找到的变量，可以使用 <a href="https://docs.python.org/zh-cn/3/reference/simple_stmts.html#nonlocal"><code>nonlocal</code></a> 语句声明为非本地变量。 如果没有被声明为非本地变量，这些变量将是只读的（尝试写入这样的变量只会在最内层作用域中创建一个 <em>新的</em> 局部变量，而同名的外部变量保持不变）。</p><p>通常，当前局部作用域将（按字面文本）引用当前函数的局部名称。 在函数以外，局部作用域将引用与全局作用域相一致的命名空间：模块的命名空间。 类定义将在局部命名空间内再放置另一个命名空间。</p><p>重要的是应该意识到作用域是按字面文本来确定的：在一个模块内定义的函数的全局作用域就是该模块的命名空间，无论该函数从什么地方或以什么别名被调用。 另一方面，实际的名称搜索是在运行时动态完成的 — 但是，Python 正在朝着 “编译时静态名称解析” 的方向发展，因此不要过于依赖动态名称解析！ （事实上，局部变量已经是被静态确定了。）</p><p>Python 的一个特殊规定是这样的 – 如果不存在生效的 <a href="https://docs.python.org/zh-cn/3/reference/simple_stmts.html#global"><code>global</code></a> 或 <a href="https://docs.python.org/zh-cn/3/reference/simple_stmts.html#nonlocal"><code>nonlocal</code></a> 语句 – 则对名称的赋值总是会进入最内层作用域。 赋值不会复制数据 — 它们只是将名称绑定到对象。 删除也是如此：语句 <code>del x</code> 会从局部作用域所引用的命名空间中移除对 <code>x</code> 的绑定。 事实上，所有引入新名称的操作都是使用局部作用域：特别地，<a href="https://docs.python.org/zh-cn/3/reference/simple_stmts.html#import"><code>import</code></a> 语句和函数定义会在局部作用域中绑定模块或函数名称。</p><p><a href="https://docs.python.org/zh-cn/3/reference/simple_stmts.html#global"><code>global</code></a> 语句可被用来表明特定变量生存于全局作用域并且应当在其中被重新绑定；<a href="https://docs.python.org/zh-cn/3/reference/simple_stmts.html#nonlocal"><code>nonlocal</code></a> 语句表明特定变量生存于外层作用域中并且应当在其中被重新绑定。</p><h3 id="9-2-1-作用域和命名空间示例-¶"><a href="#9-2-1-作用域和命名空间示例-¶" class="headerlink" title="9.2.1. 作用域和命名空间示例 ¶"></a>9.2.1. 作用域和命名空间示例 <a href="https://docs.python.org/zh-cn/3/tutorial/classes.html#scopes-and-namespaces-example" title="永久链接至标题">¶</a></h3><p>这个例子演示了如何引用不同作用域和名称空间，以及 <a href="https://docs.python.org/zh-cn/3/reference/simple_stmts.html#global"><code>global</code></a> 和 <a href="https://docs.python.org/zh-cn/3/reference/simple_stmts.html#nonlocal"><code>nonlocal</code></a> 会如何影响变量绑定:</p><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">scope_test</span>():</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">do_local</span>():</span><br>        spam = <span class="hljs-string">&quot;local spam&quot;</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">do_nonlocal</span>():</span><br>        <span class="hljs-keyword">nonlocal</span> spam<br>        spam = <span class="hljs-string">&quot;nonlocal spam&quot;</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">do_global</span>():</span><br>        <span class="hljs-keyword">global</span> spam<br>        spam = <span class="hljs-string">&quot;global spam&quot;</span><br><br>    spam = <span class="hljs-string">&quot;test spam&quot;</span><br>    do_local()<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;After local assignment:&quot;</span>, spam)<br>    do_nonlocal()<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;After nonlocal assignment:&quot;</span>, spam)<br>    do_global()<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;After global assignment:&quot;</span>, spam)<br><br>scope_test()<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;In global scope:&quot;</span>, spam)<br></code></pre></td></tr></table></figure><p>示例代码的输出是：</p><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">After local assignment: test spam<br>After <span class="hljs-keyword">nonlocal</span> assignment: <span class="hljs-keyword">nonlocal</span> spam<br>After <span class="hljs-keyword">global</span> assignment: <span class="hljs-keyword">nonlocal</span> spam<br>In <span class="hljs-keyword">global</span> scope: <span class="hljs-keyword">global</span> spam<br></code></pre></td></tr></table></figure><p>请注意 <em>局部</em> 赋值（这是默认状态）不会改变 <em>scope_test</em> 对 <em>spam</em> 的绑定。 <a href="https://docs.python.org/zh-cn/3/reference/simple_stmts.html#nonlocal"><code>nonlocal</code></a> 赋值会改变 <em>scope_test</em> 对 <em>spam</em> 的绑定，而 <a href="https://docs.python.org/zh-cn/3/reference/simple_stmts.html#global"><code>global</code></a> 赋值会改变模块层级的绑定。</p><p>您还可以发现在 <a href="https://docs.python.org/zh-cn/3/reference/simple_stmts.html#global"><code>global</code></a> 赋值之前没有 <em>spam</em> 的绑定。</p><h2 id="9-3-初探类-¶"><a href="#9-3-初探类-¶" class="headerlink" title="9.3. 初探类 ¶"></a>9.3. 初探类 <a href="https://docs.python.org/zh-cn/3/tutorial/classes.html#a-first-look-at-classes" title="永久链接至标题">¶</a></h2><p>类引入了一些新语法，三种新对象类型和一些新语义。</p><h3 id="9-3-1-类定义语法-¶"><a href="#9-3-1-类定义语法-¶" class="headerlink" title="9.3.1. 类定义语法 ¶"></a>9.3.1. 类定义语法 <a href="https://docs.python.org/zh-cn/3/tutorial/classes.html#class-definition-syntax" title="永久链接至标题">¶</a></h3><p>最简单的类定义看起来像这样:</p><figure class="highlight erlang"><table><tr><td class="code"><pre><code class="hljs erlang">class ClassName:<br>    &lt;statement-<span class="hljs-number">1</span>&gt;<br>    .<br>    .<br>    .<br>    &lt;statement-N&gt;<br></code></pre></td></tr></table></figure><p>类定义与函数定义 (<a href="https://docs.python.org/zh-cn/3/reference/compound_stmts.html#def"><code>def</code></a> 语句) 一样必须被执行才会起作用。 （你可以尝试将类定义放在 <a href="https://docs.python.org/zh-cn/3/reference/compound_stmts.html#if"><code>if</code></a> 语句的一个分支或是函数的内部。）</p><p>在实践中，类定义内的语句通常都是函数定义，但也允许有其他语句，有时还很有用 — 我们会稍后再回来说明这个问题。 在类内部的函数定义通常具有一种特别形式的参数列表，这是方法调用的约定规范所指明的 — 这个问题也将在稍后再说明。</p><p>当进入类定义时，将创建一个新的命名空间，并将其用作局部作用域 — 因此，所有对局部变量的赋值都是在这个新命名空间之内。 特别的，函数定义会绑定到这里的新函数名称。</p><p>当（从结尾处）正常离开类定义时，将创建一个 _类对象_。 这基本上是一个包围在类定义所创建命名空间内容周围的包装器；我们将在下一节了解有关类对象的更多信息。 原始的（在进入类定义之前起作用的）局部作用域将重新生效，类对象将在这里被绑定到类定义头所给出的类名称 (在这个示例中为 <code>ClassName</code>)。</p><h3 id="9-3-2-类对象-¶"><a href="#9-3-2-类对象-¶" class="headerlink" title="9.3.2. 类对象 ¶"></a>9.3.2. 类对象 <a href="https://docs.python.org/zh-cn/3/tutorial/classes.html#class-objects" title="永久链接至标题">¶</a></h3><p>类对象支持两种操作：属性引用和实例化。</p><p><em>属性引用</em> 使用 Python 中所有属性引用所使用的标准语法: <code>obj.name</code>。 有效的属性名称是类对象被创建时存在于类命名空间中的所有名称。 因此，如果类定义是这样的:</p><figure class="highlight angelscript"><table><tr><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">class</span> <span class="hljs-symbol">MyClass:</span><br><span class="hljs-symbol">    </span>&quot;&quot;&quot;<span class="hljs-symbol">A</span> <span class="hljs-symbol">simple</span> <span class="hljs-symbol">example</span> <span class="hljs-symbol">class</span>&quot;&quot;&quot;<br>    <span class="hljs-symbol">i</span> = <span class="hljs-symbol">12345</span><br><br>    <span class="hljs-symbol">def</span> <span class="hljs-symbol">f</span>(<span class="hljs-symbol">self</span>):<br>        <span class="hljs-symbol">return</span> &#x27;<span class="hljs-symbol">hello</span> <span class="hljs-symbol">world</span>&#x27;<br></code></pre></td></tr></table></figure><p>那么 <code>MyClass.i</code> 和 <code>MyClass.f</code> 就是有效的属性引用，将分别返回一个整数和一个函数对象。 类属性也可以被赋值，因此可以通过赋值来更改 <code>MyClass.i</code> 的值。 <code>__doc__</code> 也是一个有效的属性，将返回所属类的文档字符串: <code>&quot;A simple example class&quot;</code>。</p><p>类的 <em>实例化</em> 使用函数表示法。 可以把类对象视为是返回该类的一个新实例的不带参数的函数。 举例来说（假设使用上述的类）:</p><p>创建类的新 <em>实例</em> 并将此对象分配给局部变量 <code>x</code>。</p><p>实例化操作（“调用” 类对象）会创建一个空对象。 许多类喜欢创建带有特定初始状态的自定义实例。 为此类定义可能包含一个名为 <a href="https://docs.python.org/zh-cn/3/reference/datamodel.html#object.__init__" title="object.__init__"><code>__init__()</code></a> 的特殊方法，就像这样:</p><figure class="highlight ruby"><table><tr><td class="code"><pre><code class="hljs ruby"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(<span class="hljs-keyword">self</span>)</span></span>:<br>    <span class="hljs-keyword">self</span>.data = []<br></code></pre></td></tr></table></figure><p>当一个类定义了 <a href="https://docs.python.org/zh-cn/3/reference/datamodel.html#object.__init__" title="object.__init__"><code>__init__()</code></a> 方法时，类的实例化操作会自动为新创建的类实例发起调用 <a href="https://docs.python.org/zh-cn/3/reference/datamodel.html#object.__init__" title="object.__init__"><code>__init__()</code></a>。 因此在这个示例中，可以通过以下语句获得一个经初始化的新实例:</p><p>当然，<a href="https://docs.python.org/zh-cn/3/reference/datamodel.html#object.__init__" title="object.__init__"><code>__init__()</code></a> 方法还可以有额外参数以实现更高灵活性。 在这种情况下，提供给类实例化运算符的参数将被传递给 <a href="https://docs.python.org/zh-cn/3/reference/datamodel.html#object.__init__" title="object.__init__"><code>__init__()</code></a>。 例如，:</p><blockquote></blockquote><figure class="highlight python-repl"><table><tr><td class="code"><pre><code class="hljs python-repl"><span class="hljs-meta">&gt;&gt;&gt;</span> <span class="python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Complex</span>:</span></span><br><span class="hljs-meta">...</span> <span class="python">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, realpart, imagpart</span>):</span></span><br><span class="hljs-meta">...</span> <span class="python">        self.r = realpart</span><br><span class="hljs-meta">...</span> <span class="python">        self.i = imagpart</span><br><span class="hljs-meta">...</span><br><span class="hljs-meta">&gt;&gt;&gt;</span> <span class="python">x = Complex(<span class="hljs-number">3.0</span>, -<span class="hljs-number">4.5</span>)</span><br><span class="hljs-meta">&gt;&gt;&gt;</span> <span class="python">x.r, x.i</span><br>(3.0, -4.5)<br></code></pre></td></tr></table></figure><h3 id="9-3-3-实例对象-¶"><a href="#9-3-3-实例对象-¶" class="headerlink" title="9.3.3. 实例对象 ¶"></a>9.3.3. 实例对象 <a href="https://docs.python.org/zh-cn/3/tutorial/classes.html#instance-objects" title="永久链接至标题">¶</a></h3><p>现在我们能用实例对象做什么？ 实例对象所能理解的唯一操作是属性引用。 有两种有效的属性名称：数据属性和方法。</p><p><em>数据属性</em> 对应于 Smalltalk 中的 “实例变量”，以及 C++ 中的 “数据成员”。 数据属性不需要声明；像局部变量一样，它们将在第一次被赋值时产生。 例如，如果 <code>x</code> 是上面创建的 <code>MyClass</code> 的实例，则以下代码段将打印数值 <code>16</code>，且不保留任何追踪信息:</p><figure class="highlight llvm"><table><tr><td class="code"><pre><code class="hljs llvm"><span class="hljs-keyword">x</span>.counter <span class="hljs-operator">=</span> <span class="hljs-number">1</span><br>while <span class="hljs-keyword">x</span>.counter &lt; <span class="hljs-number">10</span>:<br>    <span class="hljs-keyword">x</span>.counter <span class="hljs-operator">=</span> <span class="hljs-keyword">x</span>.counter * <span class="hljs-number">2</span><br>print(<span class="hljs-keyword">x</span>.counter)<br>del <span class="hljs-keyword">x</span>.counter<br></code></pre></td></tr></table></figure><p>另一类实例属性引用称为 _方法_。 方法是 “从属于” 对象的函数。 （在 Python 中，方法这个术语并不是类实例所特有的：其他对象也可以有方法。 例如，列表对象具有 append, insert, remove, sort 等方法。 然而，在以下讨论中，我们使用方法一词将专指类实例对象的方法，除非另外显式地说明。）</p><p>实例对象的有效方法名称依赖于其所属的类。 根据定义，一个类中所有是函数对象的属性都是定义了其实例的相应方法。 因此在我们的示例中，<code>x.f</code> 是有效的方法引用，因为 <code>MyClass.f</code> 是一个函数，而 <code>x.i</code> 不是方法，因为 <code>MyClass.i</code> 不是函数。 但是 <code>x.f</code> 与 <code>MyClass.f</code> 并不是一回事 — 它是一个 _方法对象_，不是函数对象。</p><h3 id="9-3-4-方法对象-¶"><a href="#9-3-4-方法对象-¶" class="headerlink" title="9.3.4. 方法对象 ¶"></a>9.3.4. 方法对象 <a href="https://docs.python.org/zh-cn/3/tutorial/classes.html#method-objects" title="永久链接至标题">¶</a></h3><p>通常，方法在绑定后立即被调用:</p><p>在 <code>MyClass</code> 示例中，这将返回字符串 <code>&#39;hello world&#39;</code>。 但是，立即调用一个方法并不是必须的: <code>x.f</code> 是一个方法对象，它可以被保存起来以后再调用。 例如:</p><figure class="highlight isbl"><table><tr><td class="code"><pre><code class="hljs isbl"><span class="hljs-variable">xf</span> = <span class="hljs-variable">x.f</span><br><span class="hljs-variable"><span class="hljs-keyword">while</span></span> <span class="hljs-variable"><span class="hljs-literal">True</span></span>:<br>    <span class="hljs-function"><span class="hljs-title">print</span>(<span class="hljs-title">xf</span>())</span><br></code></pre></td></tr></table></figure><p>将持续打印 <code>hello world</code>，直到结束。</p><p>当一个方法被调用时到底发生了什么？ 你可能已经注意到上面调用 <code>x.f()</code> 时并没有带参数，虽然 <code>f()</code> 的函数定义指定了一个参数。 这个参数发生了什么事？ 当不带参数地调用一个需要参数的函数时 Python 肯定会引发异常 — 即使参数实际未被使用…</p><p>实际上，你可能已经猜到了答案：方法的特殊之处就在于实例对象会作为函数的第一个参数被传入。 在我们的示例中，调用 <code>x.f()</code> 其实就相当于 <code>MyClass.f(x)</code>。 总之，调用一个具有 <em>n</em> 个参数的方法就相当于调用再多一个参数的对应函数，这个参数值为方法所属实例对象，位置在其他参数之前。</p><p>如果你仍然无法理解方法的运作原理，那么查看实现细节可能会弄清楚问题。 当一个实例的非数据属性被引用时，将搜索实例所属的类。 如果被引用的属性名称表示一个有效的类属性中的函数对象，会通过打包（指向）查找到的实例对象和函数对象到一个抽象对象的方式来创建方法对象：这个抽象对象就是方法对象。 当附带参数列表调用方法对象时，将基于实例对象和参数列表构建一个新的参数列表，并使用这个新参数列表调用相应的函数对象。</p><h3 id="9-3-5-类和实例变量-¶"><a href="#9-3-5-类和实例变量-¶" class="headerlink" title="9.3.5. 类和实例变量 ¶"></a>9.3.5. 类和实例变量 <a href="https://docs.python.org/zh-cn/3/tutorial/classes.html#class-and-instance-variables" title="永久链接至标题">¶</a></h3><p>一般来说，实例变量用于每个实例的唯一数据，而类变量用于类的所有实例共享的属性和方法:</p><figure class="highlight pgsql"><table><tr><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">class</span> Dog:    kind = <span class="hljs-string">&#x27;canine&#x27;</span>         # <span class="hljs-keyword">class</span> variable shared <span class="hljs-keyword">by</span> <span class="hljs-keyword">all</span> instances    def __init__(self, <span class="hljs-type">name</span>):        self.name = <span class="hljs-type">name</span>    # instance variable <span class="hljs-keyword">unique</span> <span class="hljs-keyword">to</span> <span class="hljs-keyword">each</span> instance&gt;&gt;&gt; d = Dog(<span class="hljs-string">&#x27;Fido&#x27;</span>)&gt;&gt;&gt; e = Dog(<span class="hljs-string">&#x27;Buddy&#x27;</span>)&gt;&gt;&gt; d.kind                  # shared <span class="hljs-keyword">by</span> <span class="hljs-keyword">all</span> dogs<span class="hljs-string">&#x27;canine&#x27;</span>&gt;&gt;&gt; e.kind                  # shared <span class="hljs-keyword">by</span> <span class="hljs-keyword">all</span> dogs<span class="hljs-string">&#x27;canine&#x27;</span>&gt;&gt;&gt; d.name                  # <span class="hljs-keyword">unique</span> <span class="hljs-keyword">to</span> d<span class="hljs-string">&#x27;Fido&#x27;</span>&gt;&gt;&gt; e.name                  # <span class="hljs-keyword">unique</span> <span class="hljs-keyword">to</span> <span class="hljs-string">e&#x27;Buddy&#x27;</span><br></code></pre></td></tr></table></figure><p>正如 <a href="https://docs.python.org/zh-cn/3/tutorial/classes.html#tut-object">名称和对象</a> 中已讨论过的，共享数据可能在涉及 <a href="https://docs.python.org/zh-cn/3/glossary.html#term-mutable">mutable</a> 对象例如列表和字典的时候导致令人惊讶的结果。 例如以下代码中的 <em>tricks</em> 列表不应该被用作类变量，因为所有的 <em>Dog</em> 实例将只共享一个单独的列表:</p><figure class="highlight reasonml"><table><tr><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">class</span> Dog:    tricks = <span class="hljs-literal">[]</span>             # mistaken use <span class="hljs-keyword">of</span> a <span class="hljs-keyword">class</span> variable    def <span class="hljs-constructor">__init__(<span class="hljs-params">self</span>, <span class="hljs-params">name</span>)</span>:        self.name = name    def add<span class="hljs-constructor">_trick(<span class="hljs-params">self</span>, <span class="hljs-params">trick</span>)</span>:        self.tricks.append(trick)&gt;&gt;&gt; d = <span class="hljs-constructor">Dog(&#x27;Fido&#x27;)</span>&gt;&gt;&gt; e = <span class="hljs-constructor">Dog(&#x27;Buddy&#x27;)</span>&gt;&gt;&gt; d.add<span class="hljs-constructor">_trick(&#x27;<span class="hljs-params">roll</span> <span class="hljs-params">over</span>&#x27;)</span>&gt;&gt;&gt; e.add<span class="hljs-constructor">_trick(&#x27;<span class="hljs-params">play</span> <span class="hljs-params">dead</span>&#x27;)</span>&gt;&gt;&gt; d.tricks                # unexpectedly shared by all dogs<span class="hljs-literal">[&#x27;<span class="hljs-identifier">roll</span> <span class="hljs-identifier">over</span>&#x27;, &#x27;<span class="hljs-identifier">play</span> <span class="hljs-identifier">dead</span>&#x27;]</span><br></code></pre></td></tr></table></figure><p>正确的类设计应该使用实例变量:</p><figure class="highlight reasonml"><table><tr><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">class</span> Dog:    def <span class="hljs-constructor">__init__(<span class="hljs-params">self</span>, <span class="hljs-params">name</span>)</span>:        self.name = name        self.tricks = <span class="hljs-literal">[]</span>    # creates a <span class="hljs-keyword">new</span> empty <span class="hljs-built_in">list</span> <span class="hljs-keyword">for</span> each dog    def add<span class="hljs-constructor">_trick(<span class="hljs-params">self</span>, <span class="hljs-params">trick</span>)</span>:        self.tricks.append(trick)&gt;&gt;&gt; d = <span class="hljs-constructor">Dog(&#x27;Fido&#x27;)</span>&gt;&gt;&gt; e = <span class="hljs-constructor">Dog(&#x27;Buddy&#x27;)</span>&gt;&gt;&gt; d.add<span class="hljs-constructor">_trick(&#x27;<span class="hljs-params">roll</span> <span class="hljs-params">over</span>&#x27;)</span>&gt;&gt;&gt; e.add<span class="hljs-constructor">_trick(&#x27;<span class="hljs-params">play</span> <span class="hljs-params">dead</span>&#x27;)</span>&gt;&gt;&gt; d.tricks<span class="hljs-literal">[&#x27;<span class="hljs-identifier">roll</span> <span class="hljs-identifier">over</span>&#x27;]</span>&gt;&gt;&gt; e.tricks<span class="hljs-literal">[&#x27;<span class="hljs-identifier">play</span> <span class="hljs-identifier">dead</span>&#x27;]</span><br></code></pre></td></tr></table></figure><h2 id="9-4-补充说明-¶"><a href="#9-4-补充说明-¶" class="headerlink" title="9.4. 补充说明 ¶"></a>9.4. 补充说明 <a href="https://docs.python.org/zh-cn/3/tutorial/classes.html#random-remarks" title="永久链接至标题">¶</a></h2><p>如果同样的属性名称同时出现在实例和类中，则属性查找会优先选择实例:</p><blockquote></blockquote><figure class="highlight python-repl"><table><tr><td class="code"><pre><code class="hljs python-repl"><span class="hljs-meta">&gt;&gt;&gt;</span> <span class="python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Warehouse</span>:</span>        purpose = <span class="hljs-string">&#x27;storage&#x27;</span>        region = <span class="hljs-string">&#x27;west&#x27;</span>&gt;&gt;&gt; w1 = Warehouse()&gt;&gt;&gt; <span class="hljs-built_in">print</span>(w1.purpose, w1.region)storage west&gt;&gt;&gt; w2 = Warehouse()&gt;&gt;&gt; w2.region = <span class="hljs-string">&#x27;east&#x27;</span>&gt;&gt;&gt; <span class="hljs-built_in">print</span>(w2.purpose, w2.region)storage east</span><br></code></pre></td></tr></table></figure><p>数据属性可以被方法以及一个对象的普通用户（“客户端”）所引用。 换句话说，类不能用于实现纯抽象数据类型。 实际上，在 Python 中没有任何东西能强制隐藏数据 — 它是完全基于约定的。 （而在另一方面，用 C 语言编写的 Python 实现则可以完全隐藏实现细节，并在必要时控制对象的访问；此特性可以通过用 C 编写 Python 扩展来使用。）</p><p>客户端应当谨慎地使用数据属性 — 客户端可能通过直接操作数据属性的方式破坏由方法所维护的固定变量。 请注意客户端可以向一个实例对象添加他们自己的数据属性而不会影响方法的可用性，只要保证避免名称冲突 — 再次提醒，在此使用命名约定可以省去许多令人头痛的麻烦。</p><p>在方法内部引用数据属性（或其他方法！）并没有简便方式。 我发现这实际上提升了方法的可读性：当浏览一个方法代码时，不会存在混淆局部变量和实例变量的机会。</p><p>方法的第一个参数常常被命名为 <code>self</code>。 这也不过就是一个约定: <code>self</code> 这一名称在 Python 中绝对没有特殊含义。 但是要注意，不遵循此约定会使得你的代码对其他 Python 程序员来说缺乏可读性，而且也可以想像一个 <em>类浏览器</em> 程序的编写可能会依赖于这样的约定。</p><p>任何一个作为类属性的函数都为该类的实例定义了一个相应方法。 函数定义的文本并非必须包含于类定义之内：将一个函数对象赋值给一个局部变量也是可以的。 例如:</p><figure class="highlight angelscript"><table><tr><td class="code"><pre><code class="hljs angelscript"># Function defined outside the classdef f1(self, x, y):    <span class="hljs-keyword">return</span> min(x, x+y)<span class="hljs-keyword">class</span> <span class="hljs-symbol">C:    <span class="hljs-symbol">f</span></span> = <span class="hljs-symbol">f1</span>    <span class="hljs-symbol">def</span> <span class="hljs-symbol">g</span>(<span class="hljs-symbol">self</span>):        <span class="hljs-symbol">return</span> &#x27;<span class="hljs-symbol">hello</span> <span class="hljs-symbol">world</span>&#x27;    <span class="hljs-symbol">h</span> = <span class="hljs-symbol">g</span><br></code></pre></td></tr></table></figure><p>现在 <code>f</code>, <code>g</code> 和 <code>h</code> 都是 <code>C</code> 类的引用函数对象的属性，因而它们就都是 <code>C</code> 的实例的方法 — 其中 <code>h</code> 完全等同于 <code>g</code>。 但请注意，本示例的做法通常只会令程序的阅读者感到迷惑。</p><p>方法可以通过使用 <code>self</code> 参数的方法属性调用其他方法:</p><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Bag</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self</span>):</span>        self.data = []    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">add</span>(<span class="hljs-params">self, x</span>):</span>        self.data.append(x)    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">addtwice</span>(<span class="hljs-params">self, x</span>):</span>        self.add(x)        self.add(x)<br></code></pre></td></tr></table></figure><p>方法可以通过与普通函数相同的方式引用全局名称。 与方法相关联的全局作用域就是包含其定义的模块。 （类永远不会被作为全局作用域。） 虽然我们很少会有充分的理由在方法中使用全局作用域，但全局作用域存在许多合理的使用场景：举个例子，导入到全局作用域的函数和模块可以被方法所使用，在其中定义的函数和类也一样。 通常，包含该方法的类本身是在全局作用域中定义的，而在下一节中我们将会发现为何方法需要引用其所属类的很好的理由。</p><p>每个值都是一个对象，因此具有 <em>类</em> （也称为 _类型_），并存储为 <code>object.__class__</code> 。</p><h2 id="9-5-继承-¶"><a href="#9-5-继承-¶" class="headerlink" title="9.5. 继承 ¶"></a>9.5. 继承 <a href="https://docs.python.org/zh-cn/3/tutorial/classes.html#inheritance" title="永久链接至标题">¶</a></h2><p>当然，如果不支持继承，语言特性就不值得称为 “类”。派生类定义的语法如下所示:</p><figure class="highlight crystal"><table><tr><td class="code"><pre><code class="hljs crystal"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DerivedClassName</span>(<span class="hljs-title">BaseClassName</span>):    &lt;<span class="hljs-title">statement</span>-1&gt;    .    .    .    &lt;<span class="hljs-title">statement</span>-<span class="hljs-title">N</span>&gt;</span><br></code></pre></td></tr></table></figure><p>名称 <code>BaseClassName</code> 必须定义于包含派生类定义的作用域中。 也允许用其他任意表达式代替基类名称所在的位置。 这有时也可能会用得上，例如，当基类定义在另一个模块中的时候:</p><figure class="highlight haskell"><table><tr><td class="code"><pre><code class="hljs haskell"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-type">DerivedClassName</span>(<span class="hljs-title">modname</span>.<span class="hljs-type">BaseClassName</span>):</span><br></code></pre></td></tr></table></figure><p>派生类定义的执行过程与基类相同。 当构造类对象时，基类会被记住。 此信息将被用来解析属性引用：如果请求的属性在类中找不到，搜索将转往基类中进行查找。 如果基类本身也派生自其他某个类，则此规则将被递归地应用。</p><p>派生类的实例化没有任何特殊之处: <code>DerivedClassName()</code> 会创建该类的一个新实例。 方法引用将按以下方式解析：搜索相应的类属性，如有必要将按基类继承链逐步向下查找，如果产生了一个函数对象则方法引用就生效。</p><p>派生类可能会重写其基类的方法。 因为方法在调用同一对象的其他方法时没有特殊权限，所以调用同一基类中定义的另一方法的基类方法最终可能会调用覆盖它的派生类的方法。 （对 C++ 程序员的提示：Python 中所有的方法实际上都是 <code>virtual</code> 方法。）</p><p>在派生类中的重载方法实际上可能想要扩展而非简单地替换同名的基类方法。 有一种方式可以简单地直接调用基类方法：即调用 <code>BaseClassName.methodname(self, arguments)</code>。 有时这对客户端来说也是有用的。 （请注意仅当此基类可在全局作用域中以 <code>BaseClassName</code> 的名称被访问时方可使用此方式。）</p><p>Python 有两个内置函数可被用于继承机制：</p><ul><li><p>  使用 <a href="https://docs.python.org/zh-cn/3/library/functions.html#isinstance" title="isinstance"><code>isinstance()</code></a> 来检查一个实例的类型: <code>isinstance(obj, int)</code> 仅会在 <code>obj.__class__</code> 为 <a href="https://docs.python.org/zh-cn/3/library/functions.html#int" title="int"><code>int</code></a> 或某个派生自 <a href="https://docs.python.org/zh-cn/3/library/functions.html#int" title="int"><code>int</code></a> 的类时为 <code>True</code>。</p></li><li><p>  使用 <a href="https://docs.python.org/zh-cn/3/library/functions.html#issubclass" title="issubclass"><code>issubclass()</code></a> 来检查类的继承关系: <code>issubclass(bool, int)</code> 为 <code>True</code>，因为 <a href="https://docs.python.org/zh-cn/3/library/functions.html#bool" title="bool"><code>bool</code></a> 是 <a href="https://docs.python.org/zh-cn/3/library/functions.html#int" title="int"><code>int</code></a> 的子类。 但是，<code>issubclass(float, int)</code> 为 <code>False</code>，因为 <a href="https://docs.python.org/zh-cn/3/library/functions.html#float" title="float"><code>float</code></a> 不是 <a href="https://docs.python.org/zh-cn/3/library/functions.html#int" title="int"><code>int</code></a> 的子类。</p></li></ul><h3 id="9-5-1-多重继承-¶"><a href="#9-5-1-多重继承-¶" class="headerlink" title="9.5.1. 多重继承 ¶"></a>9.5.1. 多重继承 <a href="https://docs.python.org/zh-cn/3/tutorial/classes.html#multiple-inheritance" title="永久链接至标题">¶</a></h3><p>Python 也支持一种多重继承。 带有多个基类的类定义语句如下所示:</p><figure class="highlight haskell"><table><tr><td class="code"><pre><code class="hljs haskell"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-type">DerivedClassName</span>(<span class="hljs-type">Base1</span>, <span class="hljs-type">Base2</span>, <span class="hljs-type">Base3</span>):    &lt;statement-1&gt;    .    .    .    &lt;statement-<span class="hljs-type">N</span>&gt;</span><br></code></pre></td></tr></table></figure><p>对于多数应用来说，在最简单的情况下，你可以认为搜索从父类所继承属性的操作是深度优先、从左至右的，当层次结构中存在重叠时不会在同一个类中搜索两次。 因此，如果某一属性在 <code>DerivedClassName</code> 中未找到，则会到 <code>Base1</code> 中搜索它，然后（递归地）到 <code>Base1</code> 的基类中搜索，如果在那里未找到，再到 <code>Base2</code> 中搜索，依此类推。</p><p>真实情况比这个更复杂一些；方法解析顺序会动态改变以支持对 <a href="https://docs.python.org/zh-cn/3/library/functions.html#super" title="super"><code>super()</code></a> 的协同调用。 这种方式在某些其他多重继承型语言中被称为后续方法调用，它比单继承型语言中的 super 调用更强大。</p><p>动态改变顺序是有必要的，因为所有多重继承的情况都会显示出一个或更多的菱形关联（即至少有一个父类可通过多条路径被最底层类所访问）。 例如，所有类都是继承自 <a href="https://docs.python.org/zh-cn/3/library/functions.html#object" title="object"><code>object</code></a>，因此任何多重继承的情况都提供了一条以上的路径可以通向 <a href="https://docs.python.org/zh-cn/3/library/functions.html#object" title="object"><code>object</code></a>。 为了确保基类不会被访问一次以上，动态算法会用一种特殊方式将搜索顺序线性化， 保留每个类所指定的从左至右的顺序，只调用每个父类一次，并且保持单调（即一个类可以被子类化而不影响其父类的优先顺序）。 总而言之，这些特性使得设计具有多重继承的可靠且可扩展的类成为可能。 要了解更多细节，请参阅 <a href="https://www.python.org/download/releases/2.3/mro/">https://www.python.org/download/releases/2.3/mro/</a>。</p><h2 id="9-6-私有变量-¶"><a href="#9-6-私有变量-¶" class="headerlink" title="9.6. 私有变量 ¶"></a>9.6. 私有变量 <a href="https://docs.python.org/zh-cn/3/tutorial/classes.html#private-variables" title="永久链接至标题">¶</a></h2><p>那种仅限从一个对象内部访问的 “私有” 实例变量在 Python 中并不存在。 但是，大多数 Python 代码都遵循这样一个约定：带有一个下划线的名称 (例如 <code>_spam</code>) 应该被当作是 API 的非公有部分 (无论它是函数、方法或是数据成员)。 这应当被视为一个实现细节，可能不经通知即加以改变。</p><p>由于存在对于类私有成员的有效使用场景（例如避免名称与子类所定义的名称相冲突），因此存在对此种机制的有限支持，称为 _名称改写_。 任何形式为 <code>__spam</code> 的标识符（至少带有两个前缀下划线，至多一个后缀下划线）的文本将被替换为 <code>_classname__spam</code>，其中 <code>classname</code> 为去除了前缀下划线的当前类名称。 这种改写不考虑标识符的句法位置，只要它出现在类定义内部就会进行。</p><p>名称改写有助于让子类重载方法而不破坏类内方法调用。例如:</p><figure class="highlight n1ql"><table><tr><td class="code"><pre><code class="hljs n1ql">class Mapping:    def __init__(self, iterable):        self.items_list = []        self.__update(iterable)    def <span class="hljs-keyword">update</span>(<span class="hljs-keyword">self</span>, iterable):        <span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> iterable:            <span class="hljs-keyword">self</span>.items_list.append(item)    __update = <span class="hljs-keyword">update</span>   # <span class="hljs-keyword">private</span> copy of original <span class="hljs-keyword">update</span>() methodclass MappingSubclass(<span class="hljs-keyword">Mapping</span>):    def <span class="hljs-keyword">update</span>(<span class="hljs-keyword">self</span>, <span class="hljs-keyword">keys</span>, <span class="hljs-keyword">values</span>):        # provides new signature <span class="hljs-keyword">for</span> <span class="hljs-keyword">update</span>()        # but does <span class="hljs-keyword">not</span> <span class="hljs-keyword">break</span> __init__()        <span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> zip(<span class="hljs-keyword">keys</span>, <span class="hljs-keyword">values</span>):            <span class="hljs-keyword">self</span>.items_list.append(item)<br></code></pre></td></tr></table></figure><p>上面的示例即使在 <code>MappingSubclass</code> 引入了一个 <code>__update</code> 标识符的情况下也不会出错，因为它会在 <code>Mapping</code> 类中被替换为 <code>_Mapping__update</code> 而在 <code>MappingSubclass</code> 类中被替换为 <code>_MappingSubclass__update</code>。</p><p>请注意，改写规则的设计主要是为了避免意外冲突；访问或修改被视为私有的变量仍然是可能的。这在特殊情况下甚至会很有用，例如在调试器中。</p><p>请注意传递给 <code>exec()</code> 或 <code>eval()</code> 的代码不会将发起调用类的类名视作当前类；这类似于 <code>global</code> 语句的效果，因此这种效果仅限于同时经过字节码编译的代码。 同样的限制也适用于 <code>getattr()</code>, <code>setattr()</code> 和 <code>delattr()</code>，以及对于 <code>__dict__</code> 的直接引用。</p><h2 id="9-7-杂项说明-¶"><a href="#9-7-杂项说明-¶" class="headerlink" title="9.7. 杂项说明 ¶"></a>9.7. 杂项说明 <a href="https://docs.python.org/zh-cn/3/tutorial/classes.html#odds-and-ends" title="永久链接至标题">¶</a></h2><p>有时会需要使用类似于 Pascal 的 “record” 或 C 的 “struct” 这样的数据类型，将一些命名数据项捆绑在一起。 这种情况适合定义一个空类:</p><figure class="highlight oxygene"><table><tr><td class="code"><pre><code class="hljs oxygene"><span class="hljs-keyword">class</span> Employee:    passjohn = Employee()  # <span class="hljs-keyword">Create</span> an <span class="hljs-keyword">empty</span> employee <span class="hljs-keyword">record</span># Fill the fields <span class="hljs-keyword">of</span> the recordjohn.name = <span class="hljs-string">&#x27;John Doe&#x27;</span>john.dept = <span class="hljs-string">&#x27;computer lab&#x27;</span>john.salary = <span class="hljs-number">1000</span><br></code></pre></td></tr></table></figure><p>一段需要特定抽象数据类型的 Python 代码往往可以被传入一个模拟了该数据类型的方法的类作为替代。 例如，如果你有一个基于文件对象来格式化某些数据的函数，你可以定义一个带有 <code>read()</code> 和 <code>readline()</code> 方法从字符串缓存获取数据的类，并将其作为参数传入。</p><p>实例方法对象也具有属性: <code>m.__self__</code> 就是带有 <code>m()</code> 方法的实例对象，而 <code>m.__func__</code> 则是该方法所对应的函数对象。</p><h2 id="9-8-迭代器-¶"><a href="#9-8-迭代器-¶" class="headerlink" title="9.8. 迭代器 ¶"></a>9.8. 迭代器 <a href="https://docs.python.org/zh-cn/3/tutorial/classes.html#iterators" title="永久链接至标题">¶</a></h2><p>到目前为止，您可能已经注意到大多数容器对象都可以使用 <a href="https://docs.python.org/zh-cn/3/reference/compound_stmts.html#for"><code>for</code></a> 语句:</p><figure class="highlight processing"><table><tr><td class="code"><pre><code class="hljs processing"><span class="hljs-keyword">for</span> element in [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]:    <span class="hljs-built_in">print</span>(element)<span class="hljs-keyword">for</span> element in (<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>):    <span class="hljs-built_in">print</span>(element)<span class="hljs-keyword">for</span> <span class="hljs-built_in">key</span> in &#123;<span class="hljs-string">&#x27;one&#x27;</span>:<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;two&#x27;</span>:<span class="hljs-number">2</span>&#125;:    <span class="hljs-built_in">print</span>(<span class="hljs-built_in">key</span>)<span class="hljs-keyword">for</span> <span class="hljs-built_in">char</span> in <span class="hljs-string">&quot;123&quot;</span>:    <span class="hljs-built_in">print</span>(<span class="hljs-built_in">char</span>)<span class="hljs-keyword">for</span> <span class="hljs-built_in">line</span> in <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;myfile.txt&quot;</span>):    <span class="hljs-built_in">print</span>(<span class="hljs-built_in">line</span>, end=<span class="hljs-string">&#x27;&#x27;</span>)<br></code></pre></td></tr></table></figure><p>这种访问风格清晰、简洁又方便。 迭代器的使用非常普遍并使得 Python 成为一个统一的整体。 在幕后，<a href="https://docs.python.org/zh-cn/3/reference/compound_stmts.html#for"><code>for</code></a> 语句会在容器对象上调用 <a href="https://docs.python.org/zh-cn/3/library/functions.html#iter" title="iter"><code>iter()</code></a>。 该函数返回一个定义了 <a href="https://docs.python.org/zh-cn/3/library/stdtypes.html#iterator.__next__" title="iterator.__next__"><code>__next__()</code></a> 方法的迭代器对象，此方法将逐一访问容器中的元素。 当元素用尽时，<a href="https://docs.python.org/zh-cn/3/library/stdtypes.html#iterator.__next__" title="iterator.__next__"><code>__next__()</code></a> 将引发 <a href="https://docs.python.org/zh-cn/3/library/exceptions.html#StopIteration" title="StopIteration"><code>StopIteration</code></a> 异常来通知终止 <code>for</code> 循环。 你可以使用 <a href="https://docs.python.org/zh-cn/3/library/functions.html#next" title="next"><code>next()</code></a> 内置函数来调用 <a href="https://docs.python.org/zh-cn/3/library/stdtypes.html#iterator.__next__" title="iterator.__next__"><code>__next__()</code></a> 方法；这个例子显示了它的运作方式:</p><blockquote></blockquote><figure class="highlight livecodeserver"><table><tr><td class="code"><pre><code class="hljs livecodeserver">&gt;&gt;&gt; s = <span class="hljs-string">&#x27;abc&#x27;</span>&gt;&gt;&gt; <span class="hljs-keyword">it</span> = iter(s)&gt;&gt;&gt; <span class="hljs-keyword">it</span>&lt;iterator object <span class="hljs-keyword">at</span> <span class="hljs-number">0x00A1DB50</span>&gt;&gt;&gt;&gt; next(<span class="hljs-keyword">it</span>)<span class="hljs-string">&#x27;a&#x27;</span>&gt;&gt;&gt; next(<span class="hljs-keyword">it</span>)<span class="hljs-string">&#x27;b&#x27;</span>&gt;&gt;&gt; next(<span class="hljs-keyword">it</span>)<span class="hljs-string">&#x27;c&#x27;</span>&gt;&gt;&gt; next(<span class="hljs-keyword">it</span>)Traceback (most recent call <span class="hljs-keyword">last</span>):  File <span class="hljs-string">&quot;&lt;stdin&gt;&quot;</span>, <span class="hljs-built_in">line</span> <span class="hljs-number">1</span>, <span class="hljs-keyword">in</span> &lt;module&gt;    next(<span class="hljs-keyword">it</span>)StopIteration<br></code></pre></td></tr></table></figure><p>看过迭代器协议的幕后机制，给你的类添加迭代器行为就很容易了。 定义一个 <a href="https://docs.python.org/zh-cn/3/reference/datamodel.html#object.__iter__" title="object.__iter__"><code>__iter__()</code></a> 方法来返回一个带有 <a href="https://docs.python.org/zh-cn/3/library/stdtypes.html#iterator.__next__" title="iterator.__next__"><code>__next__()</code></a> 方法的对象。 如果类已定义了 <code>__next__()</code>，则 <a href="https://docs.python.org/zh-cn/3/reference/datamodel.html#object.__iter__" title="object.__iter__"><code>__iter__()</code></a> 可以简单地返回 <code>self</code>:</p><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Reverse</span>:</span>    <span class="hljs-string">&quot;&quot;&quot;Iterator for looping over a sequence backwards.&quot;&quot;&quot;</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, data</span>):</span>        self.data = data        self.index = <span class="hljs-built_in">len</span>(data)    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__iter__</span>(<span class="hljs-params">self</span>):</span>        <span class="hljs-keyword">return</span> self    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__next__</span>(<span class="hljs-params">self</span>):</span>        <span class="hljs-keyword">if</span> self.index == <span class="hljs-number">0</span>:            <span class="hljs-keyword">raise</span> StopIteration        self.index = self.index - <span class="hljs-number">1</span>        <span class="hljs-keyword">return</span> self.data[self.index]<br></code></pre></td></tr></table></figure><blockquote></blockquote><figure class="highlight gradle"><table><tr><td class="code"><pre><code class="hljs gradle">&gt;&gt;&gt; rev = <span class="hljs-keyword">Reverse</span>(<span class="hljs-string">&#x27;spam&#x27;</span>)&gt;&gt;&gt; iter(rev)&lt;__main__.<span class="hljs-keyword">Reverse</span> object at <span class="hljs-number">0</span>x00A1DB50&gt;&gt;&gt;&gt; <span class="hljs-keyword">for</span> <span class="hljs-keyword">char</span> in rev:...     <span class="hljs-keyword">print</span>(<span class="hljs-keyword">char</span>)...maps<br></code></pre></td></tr></table></figure><h2 id="9-9-生成器-¶"><a href="#9-9-生成器-¶" class="headerlink" title="9.9. 生成器 ¶"></a>9.9. 生成器 <a href="https://docs.python.org/zh-cn/3/tutorial/classes.html#generators" title="永久链接至标题">¶</a></h2><p><a href="https://docs.python.org/zh-cn/3/glossary.html#term-generator">生成器</a> 是一个用于创建迭代器的简单而强大的工具。 它们的写法类似于标准的函数，但当它们要返回数据时会使用 <a href="https://docs.python.org/zh-cn/3/reference/simple_stmts.html#yield"><code>yield</code></a> 语句。 每次在生成器上调用 <a href="https://docs.python.org/zh-cn/3/library/functions.html#next" title="next"><code>next()</code></a> 时，它会从上次离开的位置恢复执行（它会记住上次执行语句时的所有数据值）。 一个显示如何非常容易地创建生成器的示例如下:</p><figure class="highlight fortran"><table><tr><td class="code"><pre><code class="hljs fortran">def reverse(<span class="hljs-keyword">data</span>):    for <span class="hljs-built_in">index</span> <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(len(<span class="hljs-keyword">data</span>)-<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>):        yield <span class="hljs-keyword">data</span>[<span class="hljs-built_in">index</span>]<br></code></pre></td></tr></table></figure><blockquote></blockquote><figure class="highlight axapta"><table><tr><td class="code"><pre><code class="hljs axapta">&gt;&gt;&gt; <span class="hljs-keyword">for</span> <span class="hljs-built_in">char</span> <span class="hljs-keyword">in</span> <span class="hljs-keyword">reverse</span>(<span class="hljs-string">&#x27;golf&#x27;</span>):...     <span class="hljs-keyword">print</span>(<span class="hljs-built_in">char</span>)...flog<br></code></pre></td></tr></table></figure><p>可以用生成器来完成的操作同样可以用前一节所描述的基于类的迭代器来完成。 但生成器的写法更为紧凑，因为它会自动创建 <a href="https://docs.python.org/zh-cn/3/reference/datamodel.html#object.__iter__" title="object.__iter__"><code>__iter__()</code></a> 和 <a href="https://docs.python.org/zh-cn/3/reference/expressions.html#generator.__next__" title="generator.__next__"><code>__next__()</code></a> 方法。</p><p>另一个关键特性在于局部变量和执行状态会在每次调用之间自动保存。 这使得该函数相比使用 <code>self.index</code> 和 <code>self.data</code> 这种实例变量的方式更易编写且更为清晰。</p><p>除了会自动创建方法和保存程序状态，当生成器终结时，它们还会自动引发 <a href="https://docs.python.org/zh-cn/3/library/exceptions.html#StopIteration" title="StopIteration"><code>StopIteration</code></a>。 这些特性结合在一起，使得创建迭代器能与编写常规函数一样容易。</p><h2 id="9-10-生成器表达式-¶"><a href="#9-10-生成器表达式-¶" class="headerlink" title="9.10. 生成器表达式 ¶"></a>9.10. 生成器表达式 <a href="https://docs.python.org/zh-cn/3/tutorial/classes.html#generator-expressions" title="永久链接至标题">¶</a></h2><p>某些简单的生成器可以写成简洁的表达式代码，所用语法类似列表推导式，但外层为圆括号而非方括号。 这种表达式被设计用于生成器将立即被外层函数所使用的情况。 生成器表达式相比完整的生成器更紧凑但较不灵活，相比等效的列表推导式则更为节省内存。</p><p>例如:</p><blockquote></blockquote><figure class="highlight pgsql"><table><tr><td class="code"><pre><code class="hljs pgsql">&gt;&gt;&gt; sum(i*i <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">10</span>))                 # sum <span class="hljs-keyword">of</span> squares&gt;&gt;&gt; xvec = [<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">30</span>]&gt;&gt;&gt; yvec = [<span class="hljs-number">7</span>, <span class="hljs-number">5</span>, <span class="hljs-number">3</span>]&gt;&gt;&gt; sum(x*y <span class="hljs-keyword">for</span> x,y <span class="hljs-keyword">in</span> zip(xvec, yvec))         # dot product&gt;&gt;&gt; unique_words = <span class="hljs-keyword">set</span>(word <span class="hljs-keyword">for</span> <span class="hljs-type">line</span> <span class="hljs-keyword">in</span> page  <span class="hljs-keyword">for</span> word <span class="hljs-keyword">in</span> <span class="hljs-type">line</span>.split())&gt;&gt;&gt; valedictorian = max((student.gpa, student.name) <span class="hljs-keyword">for</span> student <span class="hljs-keyword">in</span> graduates)&gt;&gt;&gt; data = <span class="hljs-string">&#x27;golf&#x27;</span>&gt;&gt;&gt; list(data[i] <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(len(data)<span class="hljs-number">-1</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">-1</span>))[<span class="hljs-string">&#x27;f&#x27;</span>, <span class="hljs-string">&#x27;l&#x27;</span>, <span class="hljs-string">&#x27;o&#x27;</span>, <span class="hljs-string">&#x27;g&#x27;</span>]<br></code></pre></td></tr></table></figure><p>脚注</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本文由 &lt;a href=&quot;http://ksria.com/simpread/&quot;&gt;简悦 SimpRead&lt;/a&gt; 转码， 原文地址 &lt;a href=&quot;https://docs.python.org/zh-cn/3/tutorial/classes.</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="python" scheme="http://example.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>github简明教程</title>
    <link href="http://example.com/post/48e7fa72.html"/>
    <id>http://example.com/post/48e7fa72.html</id>
    <published>2021-05-24T11:28:18.000Z</published>
    <updated>2022-06-09T07:09:39.299Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文由 <a href="http://ksria.com/simpread/">简悦 SimpRead</a> 转码， 原文地址 <a href="https://www.runoob.com/w3cnote/git-guide.html">www.runoob.com</a></p></blockquote><blockquote><p>如果你是一枚 Coder，但是你不知道 Github，那么我觉的你就不是一个菜鸟级别的 Coder，因为你压根不是真正 Coder，你只是一个 Code 搬运工。</p></blockquote><p>如果你是一枚 Coder，但是你不知道 Github，那么我觉的你就不是一个菜鸟级别的 Coder，因为你压根不是真正 Coder，你只是一个 Code 搬运工。</p><p>但是你如果已经在读这篇文章了，我觉的你已经知道 Github 了。</p><p><strong>正是 Github，让社会化编程成为现实。</strong></p><h3 id="什么是-Github"><a href="#什么是-Github" class="headerlink" title="什么是 Github?"></a>什么是 Github?</h3><p>github 是一个基于 git 的代码托管平台，付费用户可以建私人仓库，我们一般的免费用户只能使用公共仓库，也就是代码要公开。</p><p>Github 由 Chris Wanstrath, PJ Hyett 与 Tom Preston-Werner 三位开发者在 2008 年 4 月创办。迄今拥有 59 名全职员工，主要提供基于 git 的版本托管服务。</p><p>目前看来，GitHub 这场冒险已经胜出。根据来自维基百科关于 GitHub 的描述，我们可以形象地看出 GitHub 的增长速度：</p><p><img src="https://cdn.jsdelivr.net/gh/wklesss/picture@latest/img/github-repos.png"></p><p>今天，GitHub 已是：</p><ul><li>  一个拥有 143 万开发者的社区。其中不乏 Linux 发明者 <a href="https://github.com/torvalds">Torvalds</a> 这样的顶级黑客，以及 Rails 创始人 <a href="https://github.com/dhh">DHH</a> 这样的年轻极客。</li><li>  这个星球上最流行的开源托管服务。目前已托管 431 万 git 项目，不仅越来越多知名开源项目迁入 GitHub，比如 Ruby on Rails、jQuery、Ruby、Erlang/OTP；近三年流行的开源库往往在 GitHub 首发，例如：<a href="https://github.com/twitter/bootstrap">BootStrap</a>、<a href="https://github.com/joyent/node">Node.js</a>、<a href="https://github.com/jashkenas/coffee-script">CoffeScript</a> 等。</li><li>  alexa 全球排名 414 的网站。</li></ul><h3 id="注册账户以及创建仓库"><a href="#注册账户以及创建仓库" class="headerlink" title="注册账户以及创建仓库"></a>注册账户以及创建仓库</h3><p>要想使用 github 第一步当然是注册 github 账号了， github 官网地址：<a href="https://github.com/">https://github.com/</a>。 之后就可以创建仓库了（免费用户只能建公共仓库），Create a New Repository，填好名称后 Create，之后会出现一些仓库的配置信息，这也是一个 git 的简单教程。</p><h3 id="Github-安装"><a href="#Github-安装" class="headerlink" title="Github 安装"></a>Github 安装</h3><ul><li>  <a href="http://code.google.com/p/git-osx-installer/downloads/list?can=3">下载 git OSX 版</a></li><li>  <a href="http://msysgit.github.io/">下载 git Windows 版</a></li><li>  <a href="http://book.git-scm.com/2_installing_git.html">下载 git Linux 版</a></li></ul><h3 id="配置-Git"><a href="#配置-Git" class="headerlink" title="配置 Git"></a>配置 Git</h3><p>首先在本地创建<code>ssh key；</code></p><figure class="highlight elixir"><table><tr><td class="code"><pre><code class="hljs elixir"><span class="hljs-variable">$ </span>ssh-keygen -t rsa -C <span class="hljs-string">&quot;your_email@youremail.com&quot;</span><br></code></pre></td></tr></table></figure><p>后面的<code>your_email@youremail.com</code>改为你在 github 上注册的邮箱，之后会要求确认路径和输入密码，我们这使用默认的一路回车就行。成功的话会在<code>~/</code>下生成<code>.ssh</code>文件夹，进去，打开<code>id_rsa.pub</code>，复制里面的<code>key</code>。</p><p>回到 github 上，进入 Account Settings（账户配置），左边选择 SSH Keys，Add SSH Key,title 随便填，粘贴在你电脑上生成的 key。</p><p><img src="https://cdn.jsdelivr.net/gh/wklesss/picture@latest/img/github-account.jpg"></p><p>为了验证是否成功，在 git bash 下输入：</p><figure class="highlight elixir"><table><tr><td class="code"><pre><code class="hljs elixir"><span class="hljs-variable">$ </span>ssh -T git<span class="hljs-variable">@github</span>.com<br></code></pre></td></tr></table></figure><p>如果是第一次的会提示是否 continue，输入 yes 就会看到：You’ve successfully authenticated, but GitHub does not provide shell access 。这就表示已成功连上 github。</p><p>接下来我们要做的就是把本地仓库传到 github 上去，在此之前还需要设置 username 和 email，因为 github 每次 commit 都会记录他们。</p><figure class="highlight verilog"><table><tr><td class="code"><pre><code class="hljs verilog">$ git <span class="hljs-keyword">config</span> --<span class="hljs-keyword">global</span> user<span class="hljs-variable">.name</span> <span class="hljs-string">&quot;your name&quot;</span><br>$ git <span class="hljs-keyword">config</span> --<span class="hljs-keyword">global</span> user<span class="hljs-variable">.email</span> <span class="hljs-string">&quot;your_email@youremail.com&quot;</span><br></code></pre></td></tr></table></figure><p>进入要上传的仓库，右键 git bash，添加远程地址：</p><figure class="highlight elixir"><table><tr><td class="code"><pre><code class="hljs elixir"><span class="hljs-variable">$ </span>git remote add origin git<span class="hljs-variable">@github</span>.<span class="hljs-symbol">com:</span>yourName/yourRepo.git<br></code></pre></td></tr></table></figure><p>后面的 yourName 和 yourRepo 表示你再 github 的用户名和刚才新建的仓库，加完之后进入. git，打开 config，这里会多出一个 remote “origin” 内容，这就是刚才添加的远程地址，也可以直接修改 config 来配置远程地址。</p><p>创建新文件夹，打开，然后执行 <code>git init</code> 以创建新的 git 仓库。</p><h3 id="检出仓库"><a href="#检出仓库" class="headerlink" title="检出仓库"></a>检出仓库</h3><p>执行如下命令以创建一个本地仓库的克隆版本：</p><figure class="highlight crmsh"><table><tr><td class="code"><pre><code class="hljs crmsh">git <span class="hljs-keyword">clone</span> <span class="hljs-title">/path</span>/to/repository<br></code></pre></td></tr></table></figure><p>如果是远端服务器上的仓库，你的命令会是这个样子：</p><figure class="highlight elixir"><table><tr><td class="code"><pre><code class="hljs elixir">git clone username<span class="hljs-variable">@host</span><span class="hljs-symbol">:/path/to/repository</span><br></code></pre></td></tr></table></figure><h3 id="工作流"><a href="#工作流" class="headerlink" title="工作流"></a>工作流</h3><p>你的本地仓库由 git 维护的三棵 “树” 组成。第一个是你的 <code>工作目录</code>，它持有实际文件；第二个是 <code>暂存区（Index）</code>，它像个缓存区域，临时保存你的改动；最后是 <code>HEAD</code>，它指向你最后一次提交的结果。</p><p>你可以提出更改（把它们添加到暂存区），使用如下命令：<br><code>git add &lt;filename&gt;</code><br><code>git add *</code><br>这是 git 基本工作流程的第一步；使用如下命令以实际提交改动：<br><code>git commit -m &quot;代码提交信息&quot;</code><br>现在，你的改动已经提交到了 <strong>HEAD</strong>，但是还没到你的远端仓库。</p><p><img src="https://cdn.jsdelivr.net/gh/wklesss/picture@latest/img/trees.png"></p><h3 id="推送改动"><a href="#推送改动" class="headerlink" title="推送改动"></a>推送改动</h3><p>你的改动现在已经在本地仓库的 <strong>HEAD</strong> 中了。执行如下命令以将这些改动提交到远端仓库：<br><code>git push origin master</code><br>可以把 <em>master</em> 换成你想要推送的任何分支。</p><p>如果你还没有克隆现有仓库，并欲将你的仓库连接到某个远程服务器，你可以使用如下命令添加：<br><code>git remote add origin &lt;server&gt;</code><br>如此你就能够将你的改动推送到所添加的服务器上去了。</p><h3 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h3><p>分支是用来将特性开发绝缘开来的。在你创建仓库的时候，<em>master</em> 是 “默认的” 分支。在其他分支上进行开发，完成后再将它们合并到主分支上。</p><p><img src="https://cdn.jsdelivr.net/gh/wklesss/picture@latest/img/branches.png"></p><p>创建一个叫做 “feature_x” 的分支，并切换过去：<br><code>git checkout -b feature_x</code><br>切换回主分支：<br><code>git checkout master</code><br>再把新建的分支删掉：<br><code>git branch -d feature_x</code><br>除非你将分支推送到远端仓库，不然该分支就是 _不为他人所见的_：<br><code>git push origin &lt;branch&gt;</code></p><h3 id="更新与合并"><a href="#更新与合并" class="headerlink" title="更新与合并"></a>更新与合并</h3><p>要更新你的本地仓库至最新改动，执行：<br><code>git pull</code><br>以在你的工作目录中 <em>获取（fetch）</em> 并 <em>合并（merge）</em> 远端的改动。<br>要合并其他分支到你的当前分支（例如 master），执行：<br><code>git merge &lt;branch&gt;</code><br>在这两种情况下，git 都会尝试去自动合并改动。遗憾的是，这可能并非每次都成功，并可能出现_冲突（conflicts）_。 这时候就需要你修改这些文件来手动合并这些_冲突（conflicts）_。改完之后，你需要执行如下命令以将它们标记为合并成功：<br><code>git add &lt;filename&gt;</code><br>在合并改动之前，你可以使用如下命令预览差异：<br><code>git diff &lt;source_branch&gt; &lt;target_branch&gt;</code></p><h3 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h3><p>为软件发布创建标签是推荐的。这个概念早已存在，在 SVN 中也有。你可以执行如下命令创建一个叫做 <em>1.0.0</em> 的标签：<br><code>git tag 1.0.0 1b2e1d63ff</code><br><em>1b2e1d63ff</em> 是你想要标记的提交 ID 的前 10 位字符。可以使用下列命令获取提交 ID：<br><code>git log</code><br>你也可以使用少一点的提交 ID 前几位，只要它的指向具有唯一性。</p><h3 id="替换本地改动"><a href="#替换本地改动" class="headerlink" title="替换本地改动"></a>替换本地改动</h3><p>假如你操作失误（当然，这最好永远不要发生），你可以使用如下命令替换掉本地改动：<br><code>git checkout -- &lt;filename&gt;</code><br>此命令会使用 HEAD 中的最新内容替换掉你的工作目录中的文件。已添加到暂存区的改动以及新文件都不会受到影响。</p><p>假如你想丢弃你在本地的所有改动与提交，可以到服务器上获取最新的版本历史，并将你本地主分支指向它：<br><code>git fetch origin</code><br><code>git reset --hard origin/master</code></p><h3 id="实用小贴士"><a href="#实用小贴士" class="headerlink" title="实用小贴士"></a>实用小贴士</h3><p>内建的图形化 git：<br><code>gitk</code><br>彩色的 git 输出：<br><code>git config color.ui true</code><br>显示历史记录时，每个提交的信息只显示一行：<br><code>git config format.pretty oneline</code><br>交互式添加文件到暂存区：<br><code>git add -i</code></p><h3 id="链接与资源"><a href="#链接与资源" class="headerlink" title="链接与资源"></a>链接与资源</h3><h4 id="图形化客户端"><a href="#图形化客户端" class="headerlink" title="图形化客户端"></a>图形化客户端</h4><ul><li>  <a href="http://gitx.laullon.com/">GitX (L) (OSX, 开源软件)</a></li><li>  <a href="http://www.git-tower.com/">Tower (OSX)</a></li><li>  <a href="http://www.sourcetreeapp.com/">Source Tree (OSX, 免费)</a></li><li>  <a href="http://mac.github.com/">GitHub for Mac (OSX, 免费)</a></li><li>  <a href="https://itunes.apple.com/gb/app/gitbox/id403388357?mt=12">GitBox (OSX, App Store)</a></li></ul><h4 id="指南和手册"><a href="#指南和手册" class="headerlink" title="指南和手册"></a>指南和手册</h4><ul><li>  <a href="http://book.git-scm.com/">Git 社区参考书</a></li><li>  <a href="http://progit.org/book/">专业 Git</a></li><li>  <a href="http://think-like-a-git.net/">像 git 那样思考</a></li><li>  <a href="http://help.github.com/">GitHub 帮助</a></li><li>  <a href="http://marklodato.github.io/visual-git-guide/index-zh-cn.html">图解 Git</a></li></ul><h4 id="相关文章"><a href="#相关文章" class="headerlink" title="相关文章"></a>相关文章</h4><ul><li>  Github 简明指南：<a href="http://rogerdudler.github.io/git-guide/index.zh.html">http://rogerdudler.github.io/git-guide/index.zh.html</a></li><li>  如何高效利用 GitHub:<a href="http://www.yangzhiping.com/tech/github.html">http://www.yangzhiping.com/tech/github.html</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本文由 &lt;a href=&quot;http://ksria.com/simpread/&quot;&gt;简悦 SimpRead&lt;/a&gt; 转码， 原文地址 &lt;a href=&quot;https://www.runoob.com/w3cnote/git-guide.html&quot;&gt;ww</summary>
      
    
    
    
    <category term="工具使用" scheme="http://example.com/categories/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/"/>
    
    
    <category term="github" scheme="http://example.com/tags/github/"/>
    
  </entry>
  
  <entry>
    <title>markdown</title>
    <link href="http://example.com/post/96be88e3.html"/>
    <id>http://example.com/post/96be88e3.html</id>
    <published>2021-05-19T15:11:32.000Z</published>
    <updated>2022-06-09T07:09:39.299Z</updated>
    
    <content type="html"><![CDATA[<p>Markdown 编辑器语法指南<br>基本技巧<br>代码<br>如果你只想高亮语句中的某个函数名或关键字，可以使用 <code>function_name()</code> 实现</p><p>通常编辑器根据代码片段适配合适的高亮方法，但你也可以用 ``` 包裹一段代码，并指定一种语言</p><figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript">$(<span class="hljs-built_in">document</span>).ready(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    alert(<span class="hljs-string">&#x27;hello world&#x27;</span>);<br>&#125;);<br></code></pre></td></tr></table></figure><p>也可以使用 4 空格缩进，再贴上代码，实现相同的的效果</p><pre><code>def g(x):    yield from range(x, 0, -1)yield from range(x)</code></pre><p>如你不需要代码高亮，可以用下面的方法禁用：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs nohighlight">```<br>标题<br>文章内容较多时，可以用标题分段：<br><br>标题1<br>======<br><br>标题2<br>-----<br><br>## 大标题 ##<br>### 小标题 ###<br>粗斜体<br>*斜体文本*    _斜体文本_<br>**粗体文本**    __粗体文本__<br>***粗斜体文本***    ___粗斜体文本___<br>链接<br>常用链接方法<br><br>文字链接 [链接名称](http://链接网址)<br>网址链接 &lt;http://链接网址&gt;<br>高级链接技巧<br><br>这个链接用 1 作为网址变量 [Google][1].<br>这个链接用 yahoo 作为网址变量 [Yahoo!][yahoo].<br>然后在文档的结尾为变量赋值（网址）<br><br>[1]: http://www.google.com/<br>[yahoo]: http://www.yahoo.com/<br>列表<br>普通无序列表<br><br>- 列表文本前使用 [减号+空格]<br>+ 列表文本前使用 [加号+空格]<br>* 列表文本前使用 [星号+空格]<br>普通有序列表<br><br>1. 列表前使用 [数字+空格]<br>2. 我们会自动帮你添加数字<br>7. 不用担心数字不对，显示的时候我们会自动把这行的 7 纠正为 3<br>列表嵌套<br><br>1. 列出所有元素：<br>    - 无序列表元素 A<br>        1. 元素 A 的有序子列表<br>    - 前面加四个空格<br>2. 列表里的多段换行：<br>    前面必须加四个空格，<br>    这样换行，整体的格式不会乱<br>3. 列表里引用：<br><br>    &gt; 前面空一行<br>    &gt; 仍然需要在 &gt;  前面加四个空格<br><br>4. 列表里代码段：<br><br></code></pre></td></tr></table></figure><pre><code>前面四个空格，之后按代码语法 ``` 书写<figure class="highlight node-repl"><table><tr><td class="code"><pre><code class="hljs node-repl"><br>        或者直接空八个，引入代码块<br>引用<br>普通引用<br><br><span class="hljs-meta">&gt;</span> <span class="javascript">引用文本前使用 [大于号+空格]</span><br><span class="hljs-meta">&gt;</span> <span class="javascript">折行可以不加，新起一行都要加上哦</span><br>引用里嵌套引用<br><br><span class="hljs-meta">&gt;</span> <span class="javascript">最外层引用</span><br><span class="hljs-meta">&gt;</span> <span class="javascript">&gt; 多一个 &gt; 嵌套一层引用</span><br><span class="hljs-meta">&gt;</span> <span class="javascript">&gt; &gt; 可以嵌套很多层</span><br>引用里嵌套列表<br><br><span class="hljs-meta">&gt;</span> <span class="javascript">- 这是引用里嵌套的一个列表</span><br><span class="hljs-meta">&gt;</span> <span class="javascript">- 还可以有子列表</span><br><span class="hljs-meta">&gt;</span> <span class="javascript">    * 子列表需要从 - 之后延后四个空格开始</span><br>    引用里嵌套代码块<br><br><span class="hljs-meta">&gt;</span> <span class="javascript">    同样的，在前面加四个空格形成代码块</span><br><span class="hljs-meta">&gt;</span> <span class="javascript"> </span><br></code></pre></td></tr></table></figure></code></pre><blockquote><p>或者使用 ``` 形成代码块</p><pre><code>图片跟链接的方法区别在于前面加了个感叹号 !，这样是不是觉得好记多了呢？</code></pre></blockquote><p><code>![图片名称](http://图片网址)</code><br>当然，你也可以像网址那样对图片网址使用变量</p><p>这个链接用 1 作为网址变量 <a href="http://www.google.com/logo.png">Google</a>.<br>然后在文档的结尾位变量赋值（网址）</p><p>换行<br>如果另起一行，只需在当前行结尾加 2 个空格</p><p>在当前行的结尾加 2 个空格<br>这行就会新起一行<br>如果是要起一个新段落，只需要空出一行即可。</p><p>分隔符<br>如果你有写分割线的习惯，可以新起一行输入三个减号-。当前后都有段落时，请空出一行：</p><p>前面的段落</p><hr><p>后面的段落</p><p>高级技巧<br>行内 HTML 元素<br>目前只支持部分段内 HTML 元素效果，包括 <kdb> <b> <i> <em> <sup> <sub> <br> ，如</p><p>键位显示</p><p>使用 <kbd>Ctrl</kbd>+<kbd>Alt</kbd>+<kbd>Del</kbd> 重启电脑<br>代码块</p><p>使用 <pre></pre> 元素同样可以形成代码块<br>粗斜体</p><p><b> Markdown 在此处同样适用，如 <em>加粗</em> </b><br>符号转义<br>如果你的描述中需要用到 markdown 的符号，比如 _ # * 等，但又不想它被转义，这时候可以在这些符号前加反斜杠，如 _ # * 进行避免。</p><p>_不想这里的文本变斜体_<br>**不想这里的文本被加粗**<br>扩展<br>支持 jsfiddle、gist、runjs、优酷视频，直接填写 url，在其之后会自动添加预览点击会展开相关内容。</p><p>http://{url_of_the_fiddle}/embedded/[{tabs}/[{style}]]/<br><a href="https://gist.github.com/%7Bgist_id%7D">https://gist.github.com/{gist_id}</a><br><a href="http://runjs.cn/detail/%7Bid%7D">http://runjs.cn/detail/{id}</a><br><a href="http://v.youku.com/v_show/id_%7Bvideo_id%7D.html">http://v.youku.com/v_show/id_{video_id}.html</a><br>公式<br>当你需要在编辑器中插入数学公式时，可以使用两个美元符 $$ 包裹 TeX 或 LaTeX 格式的数学公式来实现。提交后，问答和文章页会根据需要加载 Mathjax 对数学公式进行渲染。如：</p><p>$$ x = {-b \pm \sqrt{b^2-4ac} \over 2a}. $$</p><p>$$<br>x \href{why-equal.html}{=} y^2 + 1<br>$$<br>同时也支持 HTML 属性，如：</p><p>$$ (x+1)^2 = \class{hidden}{(x+1)(x+1)} $$</p><p>$$<br>(x+1)^2 = \cssId{step1}{\style{visibility:hidden}{(x+1)(x+1)}}<br>$$<br>游乐场</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Markdown 编辑器语法指南&lt;br&gt;基本技巧&lt;br&gt;代码&lt;br&gt;如果你只想高亮语句中的某个函数名或关键字，可以使用 &lt;code&gt;function_name()&lt;/code&gt; 实现&lt;/p&gt;
&lt;p&gt;通常编辑器根据代码片段适配合适的高亮方法，但你也可以用 ``` 包裹一段代码</summary>
      
    
    
    
    <category term="工具使用" scheme="http://example.com/categories/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/"/>
    
    
    <category term="markdown" scheme="http://example.com/tags/markdown/"/>
    
    <category term="工具" scheme="http://example.com/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>hexo  使用</title>
    <link href="http://example.com/post/65995f2c.html"/>
    <id>http://example.com/post/65995f2c.html</id>
    <published>2021-05-19T14:58:38.000Z</published>
    <updated>2022-06-09T07:09:39.299Z</updated>
    
    <content type="html"><![CDATA[<h2 id="常见命令"><a href="#常见命令" class="headerlink" title="常见命令"></a>常见命令</h2><p><code>hexo new &quot;postName&quot; #新建文章</code><br><code>hexo new page &quot;pageName&quot; #新建页面</code><br><code>hexo generate #生成静态页面至public目录</code><br><code>hexo server #开启预览访问端口（默认端口4000，&#39;ctrl + c&#39;关闭server）</code><br><code>hexo deploy #部署到GitHub</code><br><code>hexo help  # 查看帮助</code><br><code>hexo version  #查看Hexo的版本</code>  </p><h2 id="缩写："><a href="#缩写：" class="headerlink" title="缩写："></a>缩写：</h2><p><code>hexo n == hexo new</code><br><code>hexo g == hexo generate</code><br><code>hexo s == hexo server</code><br><code>hexo d == hexo deploy</code>  </p><h2 id="组合命令："><a href="#组合命令：" class="headerlink" title="组合命令："></a>组合命令：</h2><p><code>hexo s -g #生成并本地预览</code><br><code>hexo d -g #生成并上传</code>  </p><h2 id="同步仓库"><a href="#同步仓库" class="headerlink" title="同步仓库"></a>同步仓库</h2><p>依次执行:</p><p><code>git add .</code><br><code>git commit -m &quot;xxx&quot;</code><br><code>git push origin hexo</code></p><h2 id="版本回退"><a href="#版本回退" class="headerlink" title="版本回退"></a>版本回退</h2><h3 id="本地分支版本回退"><a href="#本地分支版本回退" class="headerlink" title="本地分支版本回退"></a>本地分支版本回退</h3><p>1.找到要回退的版本的commit id：   </p><p><code>git reflog </code>  or <code>git online</code></p><p>2.接着回退版本:</p><p><code>git reset --hard Obfafd</code></p><p>0bfafd就是你要回退的版本的commit id的前面几位</p><h3 id="自己的远程分支版本回退的方法"><a href="#自己的远程分支版本回退的方法" class="headerlink" title="自己的远程分支版本回退的方法"></a>自己的远程分支版本回退的方法</h3><p>如果你的错误提交已经推送到自己的远程分支了，那么就需要回滚远程分支了。<br>1.首先要回退本地分支：</p><p><code>git reflog</code>  or <code>git online</code><br><code>git reset --hard Obfafd</code></p><p>2.紧接着强制推送到远程分支：</p><p><code>git push -f</code></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;常见命令&quot;&gt;&lt;a href=&quot;#常见命令&quot; class=&quot;headerlink&quot; title=&quot;常见命令&quot;&gt;&lt;/a&gt;常见命令&lt;/h2&gt;&lt;p&gt;&lt;code&gt;hexo new &amp;quot;postName&amp;quot; #新建文章&lt;/code&gt;&lt;br&gt;&lt;code&gt;hexo</summary>
      
    
    
    
    <category term="工具使用" scheme="http://example.com/categories/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/"/>
    
    
    <category term="hexo" scheme="http://example.com/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>PicGo搭建github图床</title>
    <link href="http://example.com/post/2513fba4.html"/>
    <id>http://example.com/post/2513fba4.html</id>
    <published>2021-05-18T17:24:37.000Z</published>
    <updated>2022-06-09T07:09:39.299Z</updated>
    
    <content type="html"><![CDATA[<h1 id="PicGo-搭建-github-图床"><a href="#PicGo-搭建-github-图床" class="headerlink" title="PicGo 搭建 github 图床"></a>PicGo 搭建 github 图床</h1><p>文章链接:<a href="https://xiaowujiang.cn/posts/2513fba4/">https://xiaowujiang.cn/posts/2513fba4/</a></p><h4 id="1-下载-PicGo-并安装；"><a href="#1-下载-PicGo-并安装；" class="headerlink" title="1. 下载 PicGo 并安装；"></a>1. 下载 <a href="https://github.com/Molunerfinn/PicGo/releases">PicGo</a> 并安装；</h4><h4 id="2-生成-Githubtoken"><a href="#2-生成-Githubtoken" class="headerlink" title="2. 生成 Githubtoken"></a>2. 生成 <a href="https://github.com/">Github</a>token</h4><h5 id="步骤如下："><a href="#步骤如下：" class="headerlink" title="步骤如下："></a>步骤如下：</h5><ul><li><p>  点击个人中心，选择<code>Settings</code>, 打开个人设置页面；</p></li><li><p>  在个人设置页面选择<code>Developer Settings</code></p></li></ul><p>[<img src="https://cdn.jsdelivr.net/gh/wklesss/picture@latest/img/20210519011957.png">]</p><ul><li>  进入<code>Developer settings</code>页后，点击<code>Personal access tokens</code>打开新的页面后, 并点击右边的<code>Generate new token</code> 生成<code>token</code></li></ul><p>[<img src="https://cdn.jsdelivr.net/gh/wklesss/picture@latest/img/20210519012111.png">]</p><ul><li>  在生成<code>token</code>页面，勾选<code>repo</code></li></ul><p>[<img src="https://cdn.jsdelivr.net/gh/wklesss/picture@latest/img/20210519012126.png">]</p><h4 id="3-创建公共仓库，用来存放相关资源图片"><a href="#3-创建公共仓库，用来存放相关资源图片" class="headerlink" title="3. 创建公共仓库，用来存放相关资源图片"></a>3. 创建公共仓库，用来存放相关资源图片</h4><p> 在 github 上创建一个仓库，用来存放一些资源</p><p>[<img src="https://cdn.jsdelivr.net/gh/wklesss/picture@latest/img/20210519012144.png">]</p><h4 id="4-在-PicGo-中配置-github-图床相关信息"><a href="#4-在-PicGo-中配置-github-图床相关信息" class="headerlink" title="4. 在 PicGo 中配置 github 图床相关信息"></a>4. 在 PicGo 中配置 github 图床相关信息</h4><ul><li><p>打开 PicGo 后，先安装一个插件<code>github-plus</code>，该插件是用来将图片上传到<code>gitee</code>或<code>github</code>上，比自带的<code>github</code>图床方便 (自带的没有办法删除远程记录)</p></li><li><p>安装完成后，插件配置：</p><p>[<img src="https://cdn.jsdelivr.net/gh/wklesss/picture@latest/img/20210519012158.png">]</p><p>① 处是需要存放图片的仓库，格式为 <code>github用户名/ 仓库名</code>;</p><p>② 处是存放图片路径的仓库下的分支，默认<code>master</code>分支；</p><p>③ token 为第二步骤上生成的 <strong>github token</strong>；</p><p>④ 远程仓库存放图片的的路径，可自定义，可不填；</p><p>⑤ 自定义的图片路径，由于我使用了<code>jsDelivr</code>来实现 github 的<code>cdn缓存</code>，所以设置了此路径，如果不需要可不填；</p><p><strong>jsDelivr 路径规则：</strong> <code>https://cdn.jsdelivr.net/gh/用户名/仓库名@版本号</code>，我这边版本号设置的是<code>latest</code>表示获取最新资源。</p><p>⑥ origin 表示 仓库可以是 gitee 或<code>github</code>, 根据前面的步骤，此处只能是 github；</p><p>⑦ 将其设置为默认图床</p></li></ul><h1 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h1><ul><li><p>如果仓库需要设置自定义域名，需要将我们的资源提交到一个<code>gh-pages</code>分区</p></li><li><p>如果你的自定义域名配置 dns 区分了境外和国内，那么就需要注意，访问该仓库可能会出现 404 的情况</p><p>解决办法：</p><ul><li>  创建一条新的 cname 解析，添加一个二级域名即可</li></ul></li></ul><p><strong>EOF</strong></p><p>本文链接：<a href="https://www.cnblogs.com/xiaowj/p/13909613.html">https://www.cnblogs.com/xiaowj/p/13909613.html</a><br>关于博主：评论和私信会在第一时间回复。或者<a href="https://msg.cnblogs.com/msg/send/xiaowj">直接私信</a>我。<br>版权声明：本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-nd/4.0/" title="BY-NC-SA">BY-NC-SA</a> 许可协议。转载请注明出处！<br>声援博主：如果您觉得文章对您有帮助，可以点击文章右下角<strong>【<a href="javascript:void(0);">推荐</a>】</strong>一下。您的鼓励是博主的最大动力！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;PicGo-搭建-github-图床&quot;&gt;&lt;a href=&quot;#PicGo-搭建-github-图床&quot; class=&quot;headerlink&quot; title=&quot;PicGo 搭建 github 图床&quot;&gt;&lt;/a&gt;PicGo 搭建 github 图床&lt;/h1&gt;&lt;p&gt;文章链接:&lt;</summary>
      
    
    
    
    <category term="工具使用" scheme="http://example.com/categories/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/"/>
    
    
    <category term="github" scheme="http://example.com/tags/github/"/>
    
    <category term="图床" scheme="http://example.com/tags/%E5%9B%BE%E5%BA%8A/"/>
    
  </entry>
  
</feed>
